# 日常笔记

## 一、[20 道 JS 原理题](https://juejin.im/post/5d2ee123e51d4577614761f8)

> ### 笔记

#### 1.实现 call 方法

> 思路：将要改变 this 指向的方法挂到目标 this 上执行并返回

```
Function.prototype.mycall = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('not funciton')
  }
  context = context || window
  context.fn = this
  let arg = [...arguments].slice(1)
  let result = context.fn(...arg)
  delete context.fn
  return result
}
```

#### 2.实现 apply 方法

> 思路：将要改变 this 指向的方法挂到目标 this 上执行并返回

```
Function.prototype.myapply  = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('not funciton')
  }
  context = context || window
  context.fn = this
  let result
  if (arguments[1]) {
    result = context.fn(...arguments[1])
  } else {
    result = context.fn()
  }
  delete context.fn
  return result
}
```

#### 3.实现一个 bind 函数

> 思路：将要改变 this 指向的方法挂到目标 this 上,然后返回该函数

```
Function.prototype.mybind = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  let _this = this
  let arg = [...arguments].slice(1)
  return function F() {
    // 处理函数使用new的情况
    if (this instanceof F) {
      return new _this(...arg, ...arguments)
    } else {
      return _this.apply(context, arg.concat(...arguments))
    }
  }
}

```

#### 4.instanceof 的原理

> 思路：右边变量的原型存在于左边变量的原型链上

```
function instanceOf(left, right) {
  let leftValue = left.__proto__
  let rightValue = right.prototype
  while (true) {
    if (leftValue === null) {
      return false
    }
    if (leftValue === rightValue) {
      return true
    }
    leftValue = leftValue.__proto__
  }
}

let a=[1]
a instanceof Array
```

> > 在 while 循环中，break，continue，return 有什么区别
> >
> > break;直接结束循环，并且跳出到循环后面语句
> >
> > continue;继续执行循环体第 1 条指令，跳过 continue 后面的所有语句
> >
> > return;结束包含 while 语句的整个函数，跳转到调用者

#### 5.new 本质

> 创建一个新对象且将其隐式原型指向构造函数原型
>
> 执行构造函数
>
> 返回该对象

```
function myNew (fun) {
  return function () {
    // 创建一个新对象且将其隐式原型指向构造函数原型
    let obj = {
      __proto__ : fun.prototype
    }
    // 执行构造函数
    fun.call(obj, ...arguments)
    // 返回该对象
    return obj
  }
}

function person(name, age) {
  this.name = name
  this.age = age
}
let obj = myNew(person)('chen', 18) // {name: "chen", age: 18}
```

#### 6.Object.create 的基本实现原理

> 思路：将传入的对象作为原型

```
function create(obj) {
  function F() {}
  F.prototype = obj
  return new F()
}
```

#### 7.实现一个基本的 Promise

> 未添加异步处理等其他边界情况
>
> ① 自动执行函数，② 三个状态，③then

```
class Promise {
  constructor (fn) {
    // 三个状态
    this.state = 'pending'
    this.value = undefined
    this.reason = undefined
    let resolve = value => {
      if (this.state === 'pending') {
        this.state = 'fulfilled'
        this.value = value
      }
    }
    let reject = value => {
      if (this.state === 'pending') {
        this.state = 'rejected'
        this.reason = value
      }
    }
    // 自动执行函数
    try {
      fn(resolve, reject)
    } catch (e) {
      reject(e)
    }
  }
  // then
  then(onFulfilled, onRejected) {
    switch (this.state) {
      case 'fulfilled':
        onFulfilled()
        break
      case 'rejected':
        onRejected()
        break
      default:
    }
  }
}

//用法
new Promise((resolve,reject) =>{
    if (condition){
        resolve();
    } else {
        reject();
    }
})
```

#### 8.实现浅拷贝

> 1. ...实现

```
let copy1 = {...{x:1}}
```

> 2. Object.assign 实现

```
let copy2 = Object.assign({}, {x:1})
```

#### 9.实现一个基本的深拷贝

> 1. JOSN.stringify()/JSON.parse()

```
let obj = {a: 1, b: {x: 3}}
JSON.parse(JSON.stringify(obj))
```

> 此方法的弊端
>
> > 1、如果 obj 里面有时间对象，则 JSON.stringify 后再 JSON.parse 的结果，时间将只是字符串的形式。而不是时间对象；
> >
> > 2、如果 obj 里有 RegExp、Error 对象，则序列化的结果将只得到空对象；
> >
> > 3、如果 obj 里有函数，undefined，则序列化的结果会把函数或 undefined 丢失；
> >
> > 4、如果 obj 里有 NaN、Infinity 和-Infinity，则序列化的结果会变成 null
> >
> > 5、JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果 obj 中的对象是有构造函数生成的， 则使用 JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的 constructor
> >
> > 6、如果对象中存在循环引用的情况也无法正确实现深拷贝；

> 2. 递归拷贝

```
function deepClone(obj) {
  let copy = obj instanceof Array ? [] : {}
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      copy[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i]
    }
  }
  return copy
}
```

#### 10.使用 setTimeout 模拟 setInterval

> 可避免 setInterval 因执行时间导致的间隔执行时间不一致
>
> > 如果 setInterval 回调函数的执行时间将足够长（比指定的时间间隔长），它们将连续执行并且彼此之间没有时间间隔。
> > 当 setInterval 回调函数第二次被触发时（此时 setTimeout 函数仍在执行）setInterval 的第一次触发将被抛弃掉。当一个很长的代码块在执行时，可能把所有的 setInterval 回调函数都排在执行队列的后面，代码块执行完之后，结果便会是一大串的 setInterval 回调函数等待执行，并且这些函数之间没有间隔，直到全部完成。所以，浏览器倾向于的当没有更多 interval 的处理函数在排队时再将下一个处理函数排到队尾(这是由于间隔的问题)。

```
setTimeout (function () {
  // do something
  setTimeout (arguments.callee, 500)
}, 500)
```

#### 11.js 实现一个继承方法

> 原型链是实现继承最原始的模式，即通过 prototype 属性实现继承。
>
> 弊端
>
> 原型链中引用类型的属性会被所有实例共享的，即所有实例对象使用的是同一份数据，会相互影响。
>
> 无法向父级构造函数传参

```
//父级-构造函数
function Father() {
 this.fatherProp = true
}

//父级-原型属性
Father.prototype.getFatherValue = function() {
 return this.fatherProp
}

//子级-构造函数
function Son() {
 this.sonProp = false
}

//子级-原型属性：继承父级
//即__proto__指向父级的prototype
//若不理解请阅读《一张图彻底KO原型链(prototype,__proto__》
Son.prototype = new Father()

//子级-添加原型方法
Son.prototype.getSonValue = function() {
 return this.sonProp
}

//创建子级的实例对象
var son = new Son()
console.log(son.getFatherValue()) //true
```

> 借用构造函数继承实例属性
>
> 原型链的继承带来的问题可借用构造函数的方式解决。其核心思想是：在子级构造函数中调用父级构造函数。
>
> 如何实现在一个构造函数中调用另一个函数？——call()和 apply()
> 弊端：
>
> 这种方式是通过构造函数实现的，当然也把构造函数自身的问题带过来了——破坏了复用性。因为每个实例都创建了一份副本。

```
//核心思想
function Child () {
  Parent.call(this)
}

//例子
function Father() {
 this.arr = [1,2,3]
}

function Son() {
 //call的第一个函数是this指向的对象,即构造函数的实例对象
 Father.call(this)

 /*上面代码等同于下面这段代码：
 (function() {
  this.arr = [1,2,3]
 }).call(this)
 */
}

var son1 = new Son()
console.log(son1.arr) //1,2,3

var son2 = new Son()
son2.arr.push(4)

console.log(son2.arr) //1,2,3,4
console.log(son1.arr) //1,2,3

//解决传参问题：
function Father(name) {
 this.name = name
}

function Son(name) {
 Father.call(this, name)
}

var son1 = new Son("小名")
console.log(son1.name)  //小名

var son2 = new Son("一灯")
console.log(son2.name)  //一灯
```

> 组合继承 = 原型链 + 借用构造函数。取其长避其短：共享的用原型链，各自的借用构造函数

```
function Father(name) {
 this.name = name
 this.arr = [1,2,3]
}

Father.prototype.getName = function() {
 console.log(this.name)
}

function Son(name, age) {
 Father.call(this, name)
 this.age = age
}

Son.prototype = new Father()
Son.prototype.constructor = Son
Son.prototype.getAge = function() {
 console.log(this.age)
}

var son1 = new Son("小名", 23)
son1.arr.push(4)
console.log(son1.arr) //1,2,3,4
son1.getName()    //小名
son1.getAge()     //23

var son2 = new Son("一灯", 24)
console.log(son2.arr) //1,2,3
son1.getName()    //一灯
son1.getAge()     //24
```

> Object.create()方法

```
var person = {
 name: 'Jiang',
 friends: ['Shelby', 'Court']
}
var anotherPerson = Object.create(person)
console.log(anotherPerson.friends) // ['Shelby', 'Court']
```

> 寄生继承原型属性

```
(function () {
  let Super = function () {}
  Super.prototype = Parent.prototype
  Child.prototype = new Super()
})()
```

#### 12.实现一个双向数据绑定

```
let obj = {}
let input = document.getElementById('input')
let span = document.getElementById('span')
// 数据劫持
Object.defineProperty(obj, 'text', {
  configurable: true,
  enumerable: true,
  get() {
    console.log('获取数据了')
    return obj['text']
  },
  set(newVal) {
    console.log('数据更新了')
    input.value = newVal
    span.innerHTML = newVal
  }
})
// 输入监听
input.addEventListener('keyup', function(e) {
  obj.text = e.target.value
})
```

#### 13.rem 基本设置

```
// 原始配置
function setRem () {
  let doc = document.documentElement
  let width = doc.getBoundingClientRect().width
  let rem = width / 75
  doc.style.fontSize = rem + 'px'
}
// 监听窗口变化
addEventListener("resize", setRem)
```

#### 14.实现一个节流函数

> 思路：在规定时间内只触发一次
>
> 高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率
>
> 每次触发事件时都判断当前是否有等待执行的延时函数

```
function throttle (fn, delay) {
  // 利用闭包保存时间
  let prev = Date.now()
  return function () {
    let context = this
    let arg = arguments
    let now = Date.now()
    if (now - prev >= delay) {
      fn.apply(context, arg)
      prev = Date.now()
    }
  }
}

function fn () {
  console.log('节流')
}
addEventListener('scroll', throttle(fn, 1000))
```

#### 15.实现一个防抖函数

> 思路:在规定时间内未触发第二次，则执行
>
> 触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间
>
> 每次触发事件时都取消之前的延时调用方法

```
function debounce (fn, delay) {
  // 利用闭包保存定时器
  let timer = null
  return function () {
    let context = this
    let arg = arguments
    // 在规定时间内再次触发会先清除定时器后再重设定时器
    clearTimeout(timer)
    timer = setTimeout(function () {
      fn.apply(context, arg)
    }, delay)
  }
}

function fn () {
  console.log('防抖')
}
addEventListener('scroll', debounce(fn, 1000))
```

---

## 二、[变量提升](https://zhuanlan.zhihu.com/p/28140450)

### 笔记

> function： 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高

> var、let、const 的区别
>
> > （一）var
> >
> > var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为 undefined 。
> > 内层变量可能覆盖外层变量
> > 用来计数的循环变量泄露为全局变量
> >
> > （二）let
> >
> > 声明的全局变量不会挂在顶层对象下面
> > 所声明的变量一定要在声明后使用，否则报错，报错 ReferenceError
> > 暂时性死区，只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（ binding ）这个区域，不再受外部的影响，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。
> > 不允许重复声明
> >
> > （三）const
> >
> > 声明的全局变量不会挂在顶层对象下面
> > const 声明之后必须马上赋值，否则会报错
> > const 简单类型一旦声明就不能再更改，复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改。
> > const 一旦声明变量，就必须立即初始化，不能留到以后赋值。
> > const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。

## 2、[8 个问题看你是否真的懂 JS-常见代码题](https://juejin.im/post/5d2d146bf265da1b9163c5c9)

> 笔记

> Object.setPrototypeOf 方法的使用
>
> 将一个指定的对象的原型设置为另一个对象或者 null(既对象的[[Prototype]]内部属性).
>
> obj 将被设置原型的对象.
>
> prototype 该对象新的原型(可以是一个对象或者 null).

> Object.getPrototypeOf()方法
>
> 该方法与 Object.setPrototypeOf 方法配套，用于读取一个对象的原型对象。

```
function Rectangle() {
  // ...
}

const rec = new Rectangle();

Object.getPrototypeOf(rec) === Rectangle.prototype
// true

```

---

## 三、[制定自己团队的前端开发规范](https://juejin.im/post/5d300e0fe51d4577407b1dff)

## 四、[前端 100 问-面试题](https://juejin.im/post/5d23e750f265da1b855c7bbe)

### 笔记

#### 1.['1', '2', '3'].map(parseInt) what & why ?

```
map中这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。

而parseInt则是用来解析字符串的，使字符串成为指定基数的整数。
parseInt(string, radix)
接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。

['1', '2', '3'].map(parseInt)等同于
['1', '2', '3'].map((a,b,c)=>{return parseInt(a,b)})
结果为：[1, NaN, NaN]
```

#### 2.es6 中 class 与 es5 中对象有什么却别

> class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。
>
> class 声明内部会启用严格模式。
>
> class 的所有方法（包括静态方法和实例方法）都是不可枚举的。
>
> class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[construct]，不能使用 new 来调用。
>
> 必须使用 new 调用 class
>
> class 内部无法重写类名。

#### 3.setTimeout、Promise、Async/Await 的区别

> 我觉得这题主要是考察这三者在事件循环中的区别，事件循环中分为宏任务队列和微任务队列。
> 其中 settimeout 的回调函数放到宏任务队列里，等到执行栈清空以后执行；
> promise.then 里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；async 函数表示函数里面可能会有异步方法，await 后面跟一个表达式，async 方法执行时，遇到 await 会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。

#### 4.数据扁平化

> 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

```
Array.from(new Set(arr.flat(Infinity))).sort((a,b)=>{ return a-b})

或者

[...new Set(String(arr).split(','))].sort((a, b) => a - b).map(Number)
```

> 分步解析

```
var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]
// 扁平化flat参数为层级
let flatArr = arr.flat(4)
// 去重
let disArr = Array.from(new Set(flatArr))
// 排序
let result = disArr.sort(function(a, b) {
    return a-b
})
console.log(result)
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
```

#### 5.[React 中 setState 什么时候是同步的，什么时候是异步的？](https://github.com/sisterAn/blog)

> 在 React 中，如果是由 React 引发的事件处理（比如通过 onClick 引发的事件处理），调用 setState 不会同步更新 this.state，除此之外的 setState 调用会同步执行 this.state。所谓“除此之外”，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval 产生的异步调用。
>
> 原因：在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。

#### 6.有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣 Object.prototype.toString.call() 、 instanceof 以及 Array.isArray()

##### 1) Object.prototype.toString.call()

> 每一个继承 Object 的对象都有 toString 方法，如果 toString 方法没有重写的话，会返回 [Object type]，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 toString 方法时，会直接返回都是内容的字符串，所以我们需要使用 call 或者 apply 方法来改变 toString 方法的执行上下文
>
> 这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。

```
Object.prototype.toString.call('An') // "[object String]"
Object.prototype.toString.call(1) // "[object Number]"
Object.prototype.toString.call(Symbol(1)) // "[object Symbol]"
Object.prototype.toString.call(null) // "[object Null]"
Object.prototype.toString.call(undefined) // "[object Undefined]"
Object.prototype.toString.call(function(){}) // "[object Function]"
Object.prototype.toString.call({name: 'An'}) // "[object Object]"
```

##### 2) instanceof

> instanceof 的内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。
>
> 使用 instanceof 判断一个对象是否为数组，instanceof 会判断这个对象的原型链上是否会找到对应的 Array 的原型，找到返回 true，否则返回 false。

```
[]  instanceof Array; // true
```

> 但 instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。

```
[]  instanceof Object; // true
```

##### 3) Array.isArray()

> 功能：用来判断对象是否为数组
>
> instanceof 与 isArray

```
当检测Array实例时，Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 iframes

var iframe = document.createElement('iframe');
document.body.appendChild(iframe);
xArray = window.frames[window.frames.length-1].Array;
var arr = new xArray(1,2,3); // [1,2,3]

// Correctly checking for Array
Array.isArray(arr);  // true
Object.prototype.toString.call(arr); // true
// Considered harmful, because doesn't work though iframes
arr instanceof Array; // false
```

> Array.isArray() 与 Object.prototype.toString.call()

```
Array.isArray()是ES5新增的方法，当不存在 Array.isArray() ，可以用 Object.prototype.toString.call() 实现。

if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}
```

### 7.[改造下面的代码，使之输出 0 - 9，写出你能想到的所有解法](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/43)。

```
for (var i = 0; i< 10; i++){
	setTimeout(() => {
		console.log(i);
    }, 1000)
}
```

#### 方法一

> 原理：利用 setTimeout 函数的第三个参数，会作为回调函数的第一个参数传入

```
代码一
for (var i = 0; i < 10; i++) {
  setTimeout(i => {
    console.log(i);
  }, 1000, i)
}
代码二
for (var i = 0; i < 10; i++) {
  setTimeout(console.log, 1000, i)
}
```

#### 方法二

> 原理：利用 let 变量的特性 — 在每一次 for 循环的过程中，let 声明的变量会在当前的块级作用域里面（for 循环的 body 体，也即两个花括号之间的内容区域）创建一个文法环境（Lexical Environment），该环境里面包括了当前 for 循环过程中的 i

```
代码一
for (let i = 0; i < 10; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000)
}
等价于
for (let i = 0; i < 10; i++) {
  let _i = i;// const _i = i;
  setTimeout(() => {
    console.log(_i);
  }, 1000)
}
```

#### 方法三

> 原理：利用函数自执行的方式，把当前 for 循环过程中的 i 传递进去，构建出块级作用域。IIFE 其实并不属于闭包的范畴。

```
for (var i = 0; i < 10; i++) {
  (i => {
    setTimeout(() => {
      console.log(i);
    }, 1000)
  })(i)
}
```

#### 方法四

> 原理：

```
for (var i = 0; i< 10; i++){
    new Promise((r,ej) => ej(i)).catch(i => setTimeout(() => {
          console.log(i);
      }, 1000))
  }
```

### 8.下面代码中 a 在什么情况下会打印 1？

```
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	console.log(1);
}
```

> 答案解析 因为==会进行隐式类型转换 所以我们重写 toString 方法就可以了

```
var a = {
  i: 1,
  toString() {
    return a.i++;
  }
}

if( a == 1 && a == 2 && a == 3 ) {
  console.log(1);
}
```

### 9.实现一个 sleep 函数，比如 sleep(1000) 意味着等待 1000 毫秒，可从 Promise、Generator、Async/Await 等角度实现

> promise

```
const sleep = (time) => {
  return new Promise(resolve => setTimeout(resolve, time))
}

sleep(1000).then(() => {
    // 这里写你的骚操作
})
```

> Async/Await

```
const sleep = (time) => {
  return new Promise(resolve => setTimeout(resolve, time))
}

async function sleepAsync() {
  console.log('fuck the code')
  await sleep(1000)
  console.log('fuck the code again')
}

sleepAsync()
```

> Generator

```
function* sleepGenerator(time) {
  yield new Promise(function(resolve,reject){
    setTimeout(resolve,time);
  })
}
sleepGenerator(1000).next().value.then(()=>{console.log(1)})
```

---

## 五、[css 世界解读](https://juejin.im/post/5ce607a7e51d454f6f16eb3d)

> ### 笔记

#### 1.在 css 中，!important 的权重相当的高，但是由于宽高会被 max-width/min-width 覆盖，所以!important 会失效。

```
width: 100px!important;
min-width: 200px;
```

复制代码上面代码计算之后会被引擎解析成：

```
width: 200px;
```

#### 2.盒模型

> IE 模型： box-sizing: border-box 此模式下，元素的宽度计算为 border+padding+content 的宽度总和。
> w3c 标准模型）： box-sizing: content-box 此模式下，元素的宽度计算为 content 的宽度。

#### 3.css 实现垂直居中 --继续收集方法 至少收集 6 种

> 好基友 line-height、vertical-align 和第三者幽灵空白节点的爱恨情仇

```
<div class="container">
  <div class="dialog">自适应弹出层</div>
</div>
<style>
.container{
  position: fixed;
  top: 0; right: 0; bottom: 0; left: 0;
  background-color: rgba(0, 0, 0, .15);
  text-align: center;
  font-size: 0;
  white-space: nowrap;
  overflow: auto;
}
.container:after{
  content: '';
  display: inline-block;
  height: 100%;
  vertical-align: middle;
}
.dialog{
  display: inline-block;
  width: 400px;
  height: 400px;
  vertical-align: middle;
  text-align: left;
  font-size: 14px;
  white-space: normal;
  background: white;
}
</style>
```

### 4.float 属性的特性

> 包裹性：即此时元素 width 会像 height 一样由子元素决定，而不是默认撑满父元素。
>
> 块状化并格式化上下文：这个就是后面会讲的 BFC 特性。块状是指元素设置 float: left 之后，其 display 的计算值就成了 block。格式化上下文是指会创建一个 BFC，这个后面会讲。
>
> 没有任何 margin 合并；
>
> 脱离文档流：float 设计的初衷就是为了“文字环绕”效果，为了让文字环绕图片，就需要具备两个条件。第一是元素高度坍塌，第二是行框盒子不可与浮动元素重叠。而元素高度坍塌就导致元素后面的非浮动块状元素会和其重叠，于是他就像脱离文档流了。

### 5.BFC：块级格式化上下文

> 根元素；
> 浮动元素 (float 不为 none 的元素)；
> 绝对定位元素 (元素的 position 为 absolute 或 fixed)；
> inline-blocks(元素的 display: inline-block)；
> 表格单元格(元素的 display: table-cell，HTML 表格单元格默认属性)；
> overflow 的值不为 visible 的元素；
> 弹性盒 flex boxes (元素的 display: flex 或 inline-flex)；

### 6、图片瀑布流效果

---

## 六、[前端常用算法](https://juejin.im/post/5d341a89f265da1bac405369)

### 笔记

#### 1.冒泡排序

> 思路
>
> 冒泡排序只会操作相邻的两个数据。
>
> 每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。
>
> 一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

```
// 冒泡排序（未优化）
const bubbleSort = arr => {
	console.time('改进前冒泡排序耗时');
	const length = arr.length;
	if (length <= 1) return;
	// i < length - 1 是因为外层只需要 length-1 次就排好了，第 length 次比较是多余的。
	for (let i = 0; i < length - 1; i++) {
		// j < length - i - 1 是因为内层的 length-i-1 到 length-1 的位置已经排好了，不需要再比较一次。
		for (let j = 0; j < length - i - 1; j++) {
			if (arr[j] > arr[j + 1]) {
				const temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
	console.log('改进前 arr :', arr);
	console.timeEnd('改进前冒泡排序耗时');
};
```

> 优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。

```
// 冒泡排序（已优化）
const bubbleSort2 = arr => {
	console.time('改进后冒泡排序耗时');
	const length = arr.length;
	if (length <= 1) return;
	// i < length - 1 是因为外层只需要 length-1 次就排好了，第 length 次比较是多余的。
	for (let i = 0; i < length - 1; i++) {
		let hasChange = false; // 提前退出冒泡循环的标志位
		// j < length - i - 1 是因为内层的 length-i-1 到 length-1 的位置已经排好了，不需要再比较一次。
		for (let j = 0; j < length - i - 1; j++) {
			if (arr[j] > arr[j + 1]) {
				const temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
				hasChange = true; // 表示有数据交换
			}
		}

		if (!hasChange) break; // 如果 false 说明所有元素已经到位，没有数据交换，提前退出
	}
	console.log('改进后 arr :', arr);
	console.timeEnd('改进后冒泡排序耗时');
};
```

#### 2.插入排序

> 思路
>
> 一般人打扑克牌，整理牌的时候，都是按牌的大小（从小到大或者从大到小）整理牌的，那每摸一张新牌，就扫描自己的牌，把新牌插入到相应的位置。
>
> 插入排序的工作原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

> 步骤
>
> 从第一个元素开始，该元素可以认为已经被排序；
>
> 取出下一个元素，在已经排序的元素序列中从后向前扫描；
>
> 如果该元素（已排序）大于新元素，将该元素移到下一位置；
>
> 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；
>
> 将新元素插入到该位置后；
>
> 重复步骤 2~5。

```
// 插入排序
const insertionSort = array => {
	const len = array.length;
	if (len <= 1) return

	let preIndex, current;
	for (let i = 1; i < len; i++) {
		preIndex = i - 1; //待比较元素的下标
		current = array[i]; //当前元素
		while (preIndex >= 0 && array[preIndex] > current) {
			//前置条件之一: 待比较元素比当前元素大
			array[preIndex + 1] = array[preIndex]; //将待比较元素后移一位
			preIndex--; //游标前移一位
		}
		if (preIndex + 1 != i) {
			//避免同一个元素赋值给自身
			array[preIndex + 1] = current; //将当前元素插入预留空位
			console.log('array :', array);
		}
	}
	return array;
};
```

#### 3.选择排序

> 思路
>
> 选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

> 步骤
>
> 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
>
> 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
>
> 重复第二步，直到所有元素均排序完毕。

---

## 七、[大型项目前端架构浅谈](https://juejin.im/post/5cea1f705188250640005472)

## 八、[高级前端进阶](https://github.com/yygmind/blog)--大量前端技术点

### [JavaScript 高阶函数浅析](https://github.com/yygmind/blog/issues/36#%E6%80%9D%E8%80%83%E9%A2%98)

### [深入高阶函数应用之柯里化](https://github.com/yygmind/blog/issues/37)

## 九、[一名【合格】前端工程师的自检清单](https://juejin.im/post/5cc1da82f265da036023b628)

## 十、[前端面试每日 3+1](https://github.com/haizlin/fe-interview)

## 十一、[webpack 教程](https://juejin.im/user/5ac0e63e6fb9a028cb2dc4c0/posts)--优先参考

## 十二、[一次完整的面试过程](https://juejin.im/post/5d282541e51d4577523f2422)
