# 日常笔记

## 一、[JS 原理题](https://juejin.im/post/5d2ee123e51d4577614761f8)

> ### 笔记

#### 1.实现 call 方法

> 思路：将要改变 this 指向的方法挂到目标 this 上执行并返回

```
Function.prototype.mycall = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('not funciton')
  }
  context = context || window
  context.fn = this
  let arg = [...arguments].slice(1)
  let result = context.fn(...arg)
  delete context.fn
  return result
}
```

#### 2.实现 apply 方法

> 思路：将要改变 this 指向的方法挂到目标 this 上执行并返回

```
Function.prototype.myapply  = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('not funciton')
  }
  context = context || window
  context.fn = this
  let result
  if (arguments[1]) {
    result = context.fn(...arguments[1])
  } else {
    result = context.fn()
  }
  delete context.fn
  return result
}
```

#### 3.实现一个 bind 函数

> 思路：将要改变 this 指向的方法挂到目标 this 上,然后返回该函数

```
Function.prototype.mybind = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  let _this = this
  let arg = [...arguments].slice(1)
  return function F() {
    // 处理函数使用new的情况
    if (this instanceof F) {
      return new _this(...arg, ...arguments)
    } else {
      return _this.apply(context, arg.concat(...arguments))
    }
  }
}

```

#### 4.instanceof 的原理

> 思路：右边变量的原型存在于左边变量的原型链上

```
function instanceOf(left, right) {
  let leftValue = left.__proto__
  let rightValue = right.prototype
  while (true) {
    if (leftValue === null) {
      return false
    }
    if (leftValue === rightValue) {
      return true
    }
    leftValue = leftValue.__proto__
  }
}

let a=[1]
a instanceof Array
```

> > 在 while 循环中，break，continue，return 有什么区别
> >
> > break;直接结束循环，并且跳出到循环后面语句
> >
> > continue;继续执行循环体第 1 条指令，跳过 continue 后面的所有语句
> >
> > return;结束包含 while 语句的整个函数，跳转到调用者

#### 5.new 本质

> 创建一个新对象且将其隐式原型指向构造函数原型
>
> 执行构造函数
>
> 返回该对象

```
function myNew (fun) {
  return function () {
    // 创建一个新对象且将其隐式原型指向构造函数原型
    let obj = {
      __proto__ : fun.prototype
    }
    // 执行构造函数
    fun.call(obj, ...arguments)
    // 返回该对象
    return obj
  }
}

function person(name, age) {
  this.name = name
  this.age = age
}
let obj = myNew(person)('chen', 18) // {name: "chen", age: 18}
```

#### 6.Object.create 的基本实现原理

> 思路：将传入的对象作为原型

```
function create(obj) {
  function F() {}
  F.prototype = obj
  return new F()
}
```

#### 7.实现一个基本的 Promise

> 未添加异步处理等其他边界情况
>
> ① 自动执行函数，② 三个状态，③then

```
class Promise {
  constructor (fn) {
    // 三个状态
    this.state = 'pending'
    this.value = undefined
    this.reason = undefined
    let resolve = value => {
      if (this.state === 'pending') {
        this.state = 'fulfilled'
        this.value = value
      }
    }
    let reject = value => {
      if (this.state === 'pending') {
        this.state = 'rejected'
        this.reason = value
      }
    }
    // 自动执行函数
    try {
      fn(resolve, reject)
    } catch (e) {
      reject(e)
    }
  }
  // then
  then(onFulfilled, onRejected) {
    switch (this.state) {
      case 'fulfilled':
        onFulfilled()
        break
      case 'rejected':
        onRejected()
        break
      default:
    }
  }
}

//用法
new Promise((resolve,reject) =>{
    if (condition){
        resolve();
    } else {
        reject();
    }
})
```

#### 8.实现浅拷贝

> 1. ...实现

```
let copy1 = {...{x:1}}
```

> 2. Object.assign 实现

```
let copy2 = Object.assign({}, {x:1})
```

#### 9.实现一个基本的深拷贝

> 1. JOSN.stringify()/JSON.parse()

```
let obj = {a: 1, b: {x: 3}}
JSON.parse(JSON.stringify(obj))
```

> 此方法的弊端
>
> > 1、如果 obj 里面有时间对象，则 JSON.stringify 后再 JSON.parse 的结果，时间将只是字符串的形式。而不是时间对象；
> >
> > 2、如果 obj 里有 RegExp、Error 对象，则序列化的结果将只得到空对象；
> >
> > 3、如果 obj 里有函数，undefined，则序列化的结果会把函数或 undefined 丢失；
> >
> > 4、如果 obj 里有 NaN、Infinity 和-Infinity，则序列化的结果会变成 null
> >
> > 5、JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果 obj 中的对象是有构造函数生成的， 则使用 JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的 constructor
> >
> > 6、如果对象中存在循环引用的情况也无法正确实现深拷贝；

> 2. 递归拷贝

```
function deepClone(obj) {
  let copy = obj instanceof Array ? [] : {}
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      copy[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i]
    }
  }
  return copy
}
```

#### 10.使用 setTimeout 模拟 setInterval

> 可避免 setInterval 因执行时间导致的间隔执行时间不一致
>
> > 如果 setInterval 回调函数的执行时间将足够长（比指定的时间间隔长），它们将连续执行并且彼此之间没有时间间隔。
> > 当 setInterval 回调函数第二次被触发时（此时 setTimeout 函数仍在执行）setInterval 的第一次触发将被抛弃掉。当一个很长的代码块在执行时，可能把所有的 setInterval 回调函数都排在执行队列的后面，代码块执行完之后，结果便会是一大串的 setInterval 回调函数等待执行，并且这些函数之间没有间隔，直到全部完成。所以，浏览器倾向于的当没有更多 interval 的处理函数在排队时再将下一个处理函数排到队尾(这是由于间隔的问题)。

```
setTimeout (function () {
  // do something
  setTimeout (arguments.callee, 500)
}, 500)
```

#### 11.js 实现一个继承方法

> 原型链是实现继承最原始的模式，即通过 prototype 属性实现继承。
>
> 弊端
>
> 原型链中引用类型的属性会被所有实例共享的，即所有实例对象使用的是同一份数据，会相互影响。
>
> 无法向父级构造函数传参

```
//父级-构造函数
function Father() {
 this.fatherProp = true
}

//父级-原型属性
Father.prototype.getFatherValue = function() {
 return this.fatherProp
}

//子级-构造函数
function Son() {
 this.sonProp = false
}

//子级-原型属性：继承父级
//即__proto__指向父级的prototype
//若不理解请阅读《一张图彻底KO原型链(prototype,__proto__》
Son.prototype = new Father()

//子级-添加原型方法
Son.prototype.getSonValue = function() {
 return this.sonProp
}

//创建子级的实例对象
var son = new Son()
console.log(son.getFatherValue()) //true
```

> 借用构造函数继承实例属性
>
> 原型链的继承带来的问题可借用构造函数的方式解决。其核心思想是：在子级构造函数中调用父级构造函数。
>
> 如何实现在一个构造函数中调用另一个函数？——call()和 apply()
> 弊端：
>
> 这种方式是通过构造函数实现的，当然也把构造函数自身的问题带过来了——破坏了复用性。因为每个实例都创建了一份副本。

```
//核心思想
function Child () {
  Parent.call(this)
}

//例子
function Father() {
 this.arr = [1,2,3]
}

function Son() {
 //call的第一个函数是this指向的对象,即构造函数的实例对象
 Father.call(this)

 /*上面代码等同于下面这段代码：
 (function() {
  this.arr = [1,2,3]
 }).call(this)
 */
}

var son1 = new Son()
console.log(son1.arr) //1,2,3

var son2 = new Son()
son2.arr.push(4)

console.log(son2.arr) //1,2,3,4
console.log(son1.arr) //1,2,3

//解决传参问题：
function Father(name) {
 this.name = name
}

function Son(name) {
 Father.call(this, name)
}

var son1 = new Son("小名")
console.log(son1.name)  //小名

var son2 = new Son("一灯")
console.log(son2.name)  //一灯
```

> 组合继承 = 原型链 + 借用构造函数。取其长避其短：共享的用原型链，各自的借用构造函数

```
function Father(name) {
 this.name = name
 this.arr = [1,2,3]
}

Father.prototype.getName = function() {
 console.log(this.name)
}

function Son(name, age) {
 Father.call(this, name)
 this.age = age
}

Son.prototype = new Father()
Son.prototype.constructor = Son
Son.prototype.getAge = function() {
 console.log(this.age)
}

var son1 = new Son("小名", 23)
son1.arr.push(4)
console.log(son1.arr) //1,2,3,4
son1.getName()    //小名
son1.getAge()     //23

var son2 = new Son("一灯", 24)
console.log(son2.arr) //1,2,3
son1.getName()    //一灯
son1.getAge()     //24
```

> Object.create()方法

```
var person = {
 name: 'Jiang',
 friends: ['Shelby', 'Court']
}
var anotherPerson = Object.create(person)
console.log(anotherPerson.friends) // ['Shelby', 'Court']
```

> 寄生继承原型属性

```
(function () {
  let Super = function () {}
  Super.prototype = Parent.prototype
  Child.prototype = new Super()
})()
```

#### 12.实现一个双向数据绑定

```
let obj = {}
let input = document.getElementById('input')
let span = document.getElementById('span')
// 数据劫持
Object.defineProperty(obj, 'text', {
  configurable: true,
  enumerable: true,
  get() {
    console.log('获取数据了')
    return obj['text']
  },
  set(newVal) {
    console.log('数据更新了')
    input.value = newVal
    span.innerHTML = newVal
  }
})
// 输入监听
input.addEventListener('keyup', function(e) {
  obj.text = e.target.value
})
```

#### 13.rem 基本设置

```
// 原始配置
function setRem () {
  let doc = document.documentElement
  let width = doc.getBoundingClientRect().width
  let rem = width / 75
  doc.style.fontSize = rem + 'px'
}
// 监听窗口变化
addEventListener("resize", setRem)
```

#### 14.实现一个节流函数

> 思路：在规定时间内只触发一次
>
> 高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率
>
> 每次触发事件时都判断当前是否有等待执行的延时函数
>
> 应用场景：可以将一些事件降低触发频率。比如懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费资源；另外还有做商品预览图的放大镜效果时，不必每次鼠标移动都计算位置。

```
function throttle (fn, delay) {
  // 利用闭包保存时间
  let prev = Date.now()
  return function () {
    let context = this
    let arg = arguments
    let now = Date.now()
    if (now - prev >= delay) {
      fn.apply(context, arg)
      prev = Date.now()
    }
  }
}

function fn () {
  console.log('节流')
}
addEventListener('scroll', throttle(fn, 1000))
```

#### 15.实现一个防抖函数

> 思路:在规定时间内未触发第二次，则执行
>
> 触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间
>
> 每次触发事件时都取消之前的延时调用方法

> 应用场景：一般可以使用在用户输入停止一段时间过后再去获取数据，而不是每次输入都去获取

```
function debounce (fn, delay) {
  // 利用闭包保存定时器
  let timer = null
  return function () {
    let context = this
    let arg = arguments
    // 在规定时间内再次触发会先清除定时器后再重设定时器
    clearTimeout(timer)
    timer = setTimeout(function () {
      fn.apply(context, arg)
    }, delay)
  }
}

function fn () {
  console.log('防抖')
}
addEventListener('scroll', debounce(fn, 1000))
```

---

## 二、[变量提升](https://zhuanlan.zhihu.com/p/28140450)

### 笔记

> function： 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高

> var、let、const 的区别
>
> > （一）var
> >
> > var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为 undefined 。
> > 内层变量可能覆盖外层变量
> > 用来计数的循环变量泄露为全局变量
> >
> > （二）let
> >
> > 声明的全局变量不会挂在顶层对象下面
> > 所声明的变量一定要在声明后使用，否则报错，报错 ReferenceError
> > 暂时性死区，只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（ binding ）这个区域，不再受外部的影响，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。
> > 不允许重复声明
> >
> > （三）const
> >
> > 声明的全局变量不会挂在顶层对象下面
> > const 声明之后必须马上赋值，否则会报错
> > const 简单类型一旦声明就不能再更改，复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改。
> > const 一旦声明变量，就必须立即初始化，不能留到以后赋值。
> > const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。

## 2、[8 个问题看你是否真的懂 JS-常见代码题](https://juejin.im/post/5d2d146bf265da1b9163c5c9)

### 笔记

> Object.setPrototypeOf 方法的使用
>
> 将一个指定的对象的原型设置为另一个对象或者 null(既对象的[[Prototype]]内部属性).
>
> obj 将被设置原型的对象.
>
> prototype 该对象新的原型(可以是一个对象或者 null).

> Object.getPrototypeOf()方法
>
> 该方法与 Object.setPrototypeOf 方法配套，用于读取一个对象的原型对象。

```
function Rectangle() {
  // ...
}

const rec = new Rectangle();

Object.getPrototypeOf(rec) === Rectangle.prototype
// true

```

---

## 三、[制定自己团队的前端开发规范](https://juejin.im/post/5d300e0fe51d4577407b1dff)

## 四、[前端 100 问-面试题](https://juejin.im/post/5d23e750f265da1b855c7bbe)

### 笔记

#### 1.['1', '2', '3'].map(parseInt) what & why ?

```
map中这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。

而parseInt则是用来解析字符串的，使字符串成为指定基数的整数。
parseInt(string, radix)
接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。

['1', '2', '3'].map(parseInt)等同于
['1', '2', '3'].map((a,b,c)=>{return parseInt(a,b)})
结果为：[1, NaN, NaN]
```

#### 2.es6 中 class 与 es5 中对象有什么却别

> class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。
>
> class 声明内部会启用严格模式。
>
> class 的所有方法（包括静态方法和实例方法）都是不可枚举的。
>
> class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[construct]，不能使用 new 来调用。
>
> 必须使用 new 调用 class
>
> class 内部无法重写类名。

#### 3.setTimeout、Promise、Async/Await 的区别

> 我觉得这题主要是考察这三者在事件循环中的区别，事件循环中分为宏任务队列和微任务队列。
> 其中 settimeout 的回调函数放到宏任务队列里，等到执行栈清空以后执行；
> promise.then 里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；async 函数表示函数里面可能会有异步方法，await 后面跟一个表达式，async 方法执行时，遇到 await 会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。

#### 4.数据扁平化

> 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

```
Array.from(new Set(arr.flat(Infinity))).sort((a,b)=>{ return a-b})

或者

[...new Set(String(arr).split(','))].sort((a, b) => a - b).map(Number)
```

> 分步解析

```
var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]
// 扁平化flat参数为层级
let flatArr = arr.flat(4)
// 去重
let disArr = Array.from(new Set(flatArr))
// 排序
let result = disArr.sort(function(a, b) {
    return a-b
})
console.log(result)
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
```

#### 5.[React 中 setState 什么时候是同步的，什么时候是异步的？](https://github.com/sisterAn/blog)

> 在 React 中，如果是由 React 引发的事件处理（比如通过 onClick 引发的事件处理），调用 setState 不会同步更新 this.state，除此之外的 setState 调用会同步执行 this.state。所谓“除此之外”，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval 产生的异步调用。
>
> 原因：在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。

#### 6.有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣 Object.prototype.toString.call() 、 instanceof 以及 Array.isArray()

##### 1) Object.prototype.toString.call()

> 每一个继承 Object 的对象都有 toString 方法，如果 toString 方法没有重写的话，会返回 [Object type]，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 toString 方法时，会直接返回都是内容的字符串，所以我们需要使用 call 或者 apply 方法来改变 toString 方法的执行上下文
>
> 这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。

```
Object.prototype.toString.call('An') // "[object String]"
Object.prototype.toString.call(1) // "[object Number]"
Object.prototype.toString.call(Symbol(1)) // "[object Symbol]"
Object.prototype.toString.call(null) // "[object Null]"
Object.prototype.toString.call(undefined) // "[object Undefined]"
Object.prototype.toString.call(function(){}) // "[object Function]"
Object.prototype.toString.call({name: 'An'}) // "[object Object]"
```

##### 2) instanceof

> instanceof 的内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。
>
> 使用 instanceof 判断一个对象是否为数组，instanceof 会判断这个对象的原型链上是否会找到对应的 Array 的原型，找到返回 true，否则返回 false。

```
[]  instanceof Array; // true
```

> 但 instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。

```
[]  instanceof Object; // true
```

##### 3) Array.isArray()

> 功能：用来判断对象是否为数组
>
> instanceof 与 isArray

```
当检测Array实例时，Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 iframes

var iframe = document.createElement('iframe');
document.body.appendChild(iframe);
xArray = window.frames[window.frames.length-1].Array;
var arr = new xArray(1,2,3); // [1,2,3]

// Correctly checking for Array
Array.isArray(arr);  // true
Object.prototype.toString.call(arr); // true
// Considered harmful, because doesn't work though iframes
arr instanceof Array; // false
```

> Array.isArray() 与 Object.prototype.toString.call()

```
Array.isArray()是ES5新增的方法，当不存在 Array.isArray() ，可以用 Object.prototype.toString.call() 实现。

if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}
```

### 7.[改造下面的代码，使之输出 0 - 9，写出你能想到的所有解法](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/43)。

理解闭包--常见面试题

```
for (var i = 0; i< 10; i++){
	setTimeout(() => {
		console.log(i);
    }, 1000)
}
```

#### 方法一

> 原理：利用 setTimeout 函数的第三个参数，会作为回调函数的第一个参数传入

```
代码一
for (var i = 0; i < 10; i++) {
  setTimeout(i => {
    console.log(i);
  }, 1000, i)
}
代码二
for (var i = 0; i < 10; i++) {
  setTimeout(console.log, 1000, i)
}
```

#### 方法二

> 原理：利用 let 变量的特性 — 在每一次 for 循环的过程中，let 声明的变量会在当前的块级作用域里面（for 循环的 body 体，也即两个花括号之间的内容区域）创建一个文法环境（Lexical Environment），该环境里面包括了当前 for 循环过程中的 i

```
代码一
for (let i = 0; i < 10; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000)
}
等价于
for (let i = 0; i < 10; i++) {
  let _i = i;// const _i = i;
  setTimeout(() => {
    console.log(_i);
  }, 1000)
}
```

#### 方法三

> 原理：利用函数自执行的方式，把当前 for 循环过程中的 i 传递进去，构建出块级作用域。IIFE 其实并不属于闭包的范畴。

```
for (var i = 0; i < 10; i++) {
  (i => {
    setTimeout(() => {
      console.log(i);
    }, 1000)
  })(i)
}
```

#### 方法四

> 原理：

```
for (var i = 0; i< 10; i++){
    new Promise((r,ej) => ej(i)).catch(i => setTimeout(() => {
          console.log(i);
      }, 1000))
  }
```

### 8.下面代码中 a 在什么情况下会打印 1？

```
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	console.log(1);
}
```

> 答案解析 因为==会进行隐式类型转换 所以我们重写 toString 方法就可以了

```
var a = {
  i: 1,
  toString() {
    return a.i++;
  }
}

if( a == 1 && a == 2 && a == 3 ) {
  console.log(1);
}
```

### 9.实现一个 sleep 函数，比如 sleep(1000) 意味着等待 1000 毫秒，可从 Promise、Generator、Async/Await 等角度实现

> promise

```
const sleep = (time) => {
  return new Promise(resolve => setTimeout(resolve, time))
}

sleep(1000).then(() => {
    // 这里写你的骚操作
})
```

> Async/Await

```
const sleep = (time) => {
  return new Promise(resolve => setTimeout(resolve, time))
}

async function sleepAsync() {
  console.log('fuck the code')
  await sleep(1000)
  console.log('fuck the code again')
}

sleepAsync()
```

> Generator

```
function* sleepGenerator(time) {
  yield new Promise(function(resolve,reject){
    setTimeout(resolve,time);
  })
}
sleepGenerator(1000).next().value.then(()=>{console.log(1)})
```

### 10.EventBus 概要

EventBus 是消息传递的一种方式，基于一个消息中心，订阅和发布消息的模式。这种方式的实现不仅仅局限于前端，在 iOS 中的消息消息中心也是如此实现。

设计模式：订阅者发布者模式，这种设计模式在前端很常见。

API 的设计：

2.1 只能构造一个消息对象

2.2 on(‘msgName’, func)订阅消息，msgName:订阅的消息名称 func: 订阅的消息

2.3 one(‘msgName’, func)仅订阅一次消息，后订阅的会替换前面订阅的消息

2.4 emit(‘msgName’, msg)发布消息 msgName:消息名称 msg：发布的消息

2.5 off(‘msgName’)移除消息

> 实现 EventBus

```
// 构造EventBus
function EventBusClass() {
    this.msgQueues = {}
}

EventBusClass.prototype = {
    // 将消息保存到当前的消息队列中
    on: function(msgName, func) {
        if (this.msgQueues.hasOwnProperty(msgName)) {
            if (typeof this.msgQueues === 'function') {
                this.msgQueues[msgName] = [this.msgQueues[msgName], func]
            } else {
                this.msgQueues[msgName] = [...this.msgQueues[msgName], func]
            }
        } else {
            this.msgQueues[msgName] = func;
        }
    },
    // 消息队列中仅保存一个消息
    one: function(msgName, func) {
        // 无需检查msgName是否存在
        this.msgQueues[msgName] = func;
    },
    // 发送消息
    emit: function(msgName, msg) {
        if (!this.msgQueues.hasOwnProperty(msgName)) {
            return
        }
        if (typeof this.msgQueues[msgName] === 'function') {
            this.msgQueues[msgName](msg)
        } else {
            this.msgQueues[msgName].map((fn) => {
                fn(msg)
            })
        }
    },
    // 移除消息
    off: function(msgName) {
        if (!this.msgQueues.hasOwnProperty(msgName)) {
            return
        }
        delete this.msgQueues[msgName]
    }
}

// 将EventBus放到window对象中
const EventBus = new EventBusClass()
window.EventBus = EventBus
```

> 使用 EventBus

```
// 订阅消息
function subscribe() {
    EventBus.on('first-event', function(msg) {
        alert(`订阅的消息是：${msg}`);
    });
}

// 发送消息
function emit() {
    const msgInput = document.getElementById("msgInputId")
    EventBus.emit('first-event', msgInput.value)
}

// 移除消息
function off(msgName) {
    EventBus.off(msgName)
}
```

> 总结
>
> 整个 EventBus 主要部分是分为三个部分。消息中心，订阅事件方法，发布消息方法。虽然不能和 Vue 中实现的那么全面，但麻雀虽小，五脏俱全。缺少的部分在于对数据安全性的校验。

---

## 五、[css 世界解读](https://juejin.im/post/5ce607a7e51d454f6f16eb3d)

> ### 笔记

#### 1.在 css 中，!important 的权重相当的高，但是由于宽高会被 max-width/min-width 覆盖，所以!important 会失效。

```
width: 100px!important;
min-width: 200px;
```

复制代码上面代码计算之后会被引擎解析成：

```
width: 200px;
```

#### 2.盒模型

> IE 模型： box-sizing: border-box 此模式下，元素的宽度计算为 border+padding+content 的宽度总和。
> w3c 标准模型）： box-sizing: content-box 此模式下，元素的宽度计算为 content 的宽度。

#### 3.css 实现垂直居中 --继续收集方法 至少收集 6 种

> 好基友 line-height、vertical-align 和第三者幽灵空白节点的爱恨情仇

```
<div class="container">
  <div class="dialog">自适应弹出层</div>
</div>
<style>
.container{
  position: fixed;
  top: 0; right: 0; bottom: 0; left: 0;
  background-color: rgba(0, 0, 0, .15);
  text-align: center;
  font-size: 0;
  white-space: nowrap;
  overflow: auto;
}
.container:after{
  content: '';
  display: inline-block;
  height: 100%;
  vertical-align: middle;
}
.dialog{
  display: inline-block;
  width: 400px;
  height: 400px;
  vertical-align: middle;
  text-align: left;
  font-size: 14px;
  white-space: normal;
  background: white;
}
</style>
```

> 另外五种

```
1.transform
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%,-50%);
2.flex
    display: flex;//flex布局
    justify-content: center;//使子项目水平居中
    align-items: center;//使子项目垂直居中
3. table
    display: table-cell;
    vertical-align: middle;//使子元素垂直居中
    text-align: center;//使子元素水平居中
4.write-mode
.wp {
    writing-mode: vertical-lr;
    text-align: center;
}
.wp-inner {
    writing-mode: horizontal-tb;
    display: inline-block;
    text-align: center;
    width: 100%;
}
.box {
    display: inline-block;
    margin: auto;
    text-align: left;
}
5.grid
    .wp {
        display: grid;
    }
    .box {
        align-self: center;
        justify-self: center;
    }

```

### 4.float 属性的特性

> 包裹性：即此时元素 width 会像 height 一样由子元素决定，而不是默认撑满父元素。
>
> 块状化并格式化上下文：这个就是后面会讲的 BFC 特性。块状是指元素设置 float: left 之后，其 display 的计算值就成了 block。格式化上下文是指会创建一个 BFC，这个后面会讲。
>
> 没有任何 margin 合并；
>
> 脱离文档流：float 设计的初衷就是为了“文字环绕”效果，为了让文字环绕图片，就需要具备两个条件。第一是元素高度坍塌，第二是行框盒子不可与浮动元素重叠。而元素高度坍塌就导致元素后面的非浮动块状元素会和其重叠，于是他就像脱离文档流了。

### 5.BFC：块级格式化上下文

> 根元素；
> 浮动元素 (float 不为 none 的元素)；
> 绝对定位元素 (元素的 position 为 absolute 或 fixed)；
> inline-blocks(元素的 display: inline-block)；
> 表格单元格(元素的 display: table-cell，HTML 表格单元格默认属性)；
> overflow 的值不为 visible 的元素；
> 弹性盒 flex boxes (元素的 display: flex 或 inline-flex)；

### 6、图片瀑布流效果

new Image 用法

创建一个 Image 对象：var a=new Image(); 定义 Image 对象的 src: a.src=”xxx.gif”; 这样做就相当于给浏览器缓存了一张图片。

图像对象：
建立图像对象：图像对象名称=new Image([宽度],[高度])

图像对象的属性： border complete height hspace lowsrc name src vspace width

图像对象的事件：onabort onerror onkeydown onkeypress onkeyup onload

需要注意的是：src 属性一定要写到 onload 的后面，否则程序在 IE 中会出错。

参考代码：

```
var img=new Image();
    img.onload=function(){alert("img is loaded")};
    img.onerror=function(){alert("error!")};
    img.src="http://www.abaonet.com/img.gif";
    function show(){alert("body is loaded");};
    window.onload=show;
```

运行上面的代码后，在不同的浏览器中进行测试，发现 IE 和 FF 是有区别的，在 FF 中，img 对象的加载包含在 body 的加载过程中，既是 img 加载完之后，body 才算是加载完毕，触发 window.onload 事件。在 IE 中，img 对象的加载是不包含在 body 的加载过程之中的，body 加载完毕，window.onload 事件触发时，img 对象可能还未加载结束，img.onload 事件会在 window.onload 之后触发。根据上面的问题，考虑到浏览器的兼容性和网页的加载时间，尽量不要在 Image 对象里放置过多的图片，否则在 FF 下会影响网页的下载速度。当然如果你在 window.onload 之后，执行预加载函数，就不会有 FF 中的问题了。可以通过 Image 对象的 complete 属性来检测图像是否加载完成（每个 Image 对象都有一个 complete 属性，当图像处于装载过程中时，该属性值 false,当发生了 onload、onerror、onabort 中任何一个事件后，则表示图像装载过程结束（不管成没成功），此时 complete 属性为 true）

### 7、文本控制

#### 1) ::first-letter 应用实例

#### 2) text-transform 应用

假设有个输入框只能输入大写字母，那么如下设置，输入小写字母出现的却是大写字母，可用于身份证输入框或验证码输入框等：

```
input {
    text-transform: uppercase;
  }
```

#### 3) word-spacing 空格间隙

不要被表面意思误导，word-spacing 指的是字符“空格”的间隙。如果一段文字中没有空格，则该属性无效。下面代码设定空格间隙是 20px，也就是说空格现在占据的宽度是原有的空格宽度+20px 的宽度：

```
<p>我有空 格，我该死......</p>
<style>
  p {
    word-spacing: 20px;
  }
</style>
```

#### 4) white-space 空白处理

我们都知道如果在 html 中输入多个空白符，默认会被当成一个空白符处理，实际上就是这个属性控制的

normal：合并空白符和换行符；
nowrap：合并空白符，但不许换行；
pre：不合并空白符，并且只在有换行符的地方换行；
pre-wrap：不合并空白符，允许换行符换行和文本自动换行；

#### 5) text-align: justify

text-align: justify 为两端对齐。除了实现文字的两端对齐，还能用来做一些两端对齐的布局。

### 8、position的值

>absolute

生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。

元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。

> fixed

生成绝对定位的元素，相对于浏览器窗口进行定位。

元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。

>relative

生成相对定位的元素，相对于其正常位置进行定位。

因此，"left:20" 会向元素的 LEFT 位置添加 20 像素。

>static	默认值。

没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。

>inherit	

规定应该从父元素继承 position 属性的值

## 六、[前端常用算法](https://juejin.im/post/5d341a89f265da1bac405369)

### 笔记

#### 1.冒泡排序

> 思路
>
> 冒泡排序只会操作相邻的两个数据。
>
> 每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。
>
> 一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

```
// 冒泡排序（未优化）
const bubbleSort = arr => {
	console.time('改进前冒泡排序耗时');
	const length = arr.length;
	if (length <= 1) return;
	// i < length - 1 是因为外层只需要 length-1 次就排好了，第 length 次比较是多余的。
	for (let i = 0; i < length - 1; i++) {
		// j < length - i - 1 是因为内层的 length-i-1 到 length-1 的位置已经排好了，不需要再比较一次。
		for (let j = 0; j < length - i - 1; j++) {
			if (arr[j] > arr[j + 1]) {
				const temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
	console.log('改进前 arr :', arr);
	console.timeEnd('改进前冒泡排序耗时');
};
```

> 优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。

```
// 冒泡排序（已优化）
const bubbleSort2 = arr => {
	console.time('改进后冒泡排序耗时');
	const length = arr.length;
	if (length <= 1) return;
	// i < length - 1 是因为外层只需要 length-1 次就排好了，第 length 次比较是多余的。
	for (let i = 0; i < length - 1; i++) {
		let hasChange = false; // 提前退出冒泡循环的标志位
		// j < length - i - 1 是因为内层的 length-i-1 到 length-1 的位置已经排好了，不需要再比较一次。
		for (let j = 0; j < length - i - 1; j++) {
			if (arr[j] > arr[j + 1]) {
				const temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
				hasChange = true; // 表示有数据交换
			}
		}

		if (!hasChange) break; // 如果 false 说明所有元素已经到位，没有数据交换，提前退出
	}
	console.log('改进后 arr :', arr);
	console.timeEnd('改进后冒泡排序耗时');
};
```

#### 2.插入排序

> 思路
>
> 一般人打扑克牌，整理牌的时候，都是按牌的大小（从小到大或者从大到小）整理牌的，那每摸一张新牌，就扫描自己的牌，把新牌插入到相应的位置。
>
> 插入排序的工作原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

> 步骤
>
> 从第一个元素开始，该元素可以认为已经被排序；
>
> 取出下一个元素，在已经排序的元素序列中从后向前扫描；
>
> 如果该元素（已排序）大于新元素，将该元素移到下一位置；
>
> 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；
>
> 将新元素插入到该位置后；
>
> 重复步骤 2~5。

```
// 插入排序
const insertionSort = array => {
	const len = array.length;
	if (len <= 1) return

	let preIndex, current;
	for (let i = 1; i < len; i++) {
		preIndex = i - 1; //待比较元素的下标
		current = array[i]; //当前元素
		while (preIndex >= 0 && array[preIndex] > current) {
			//前置条件之一: 待比较元素比当前元素大
			array[preIndex + 1] = array[preIndex]; //将待比较元素后移一位
			preIndex--; //游标前移一位
		}
		if (preIndex + 1 != i) {
			//避免同一个元素赋值给自身
			array[preIndex + 1] = current; //将当前元素插入预留空位
			console.log('array :', array);
		}
	}
	return array;
};
```

#### 3.选择排序

> 思路
>
> 选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

> 步骤
>
> 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
>
> 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
>
> 重复第二步，直到所有元素均排序完毕。

---

## 七、[大型项目前端架构浅谈](https://juejin.im/post/5cea1f705188250640005472)

## 八、[高级前端进阶](https://github.com/yygmind/blog)--大量前端技术点

### 笔记

### 1、高阶函数

高阶函数英文叫 Higher-order function，它的定义很简单，就是至少满足下列一个条件的函数：

接受一个或多个函数作为输入

输出一个函数

也就是说高阶函数是对其他函数进行操作的函数，可以将它们作为参数传递，或者是返回它们。 简单来说，高阶函数是一个接收函数作为参数传递或者将函数作为返回值输出的函数。

#### 1) 函数作为参数传递

JavaScript 语言中内置了一些高阶函数，比如 Array.prototype.map，Array.prototype.filter 和 Array.prototype.reduce，它们接受一个函数作为参数，并应用这个函数到列表的每一个元素。我们来看看使用它们与不使用高阶函数的方案对比

> Array.prototype.map
>
> map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果，原始数组不会改变。传递给 map 的回调函数（callback）接受三个参数，分别是 currentValue、index（可选）、array（可选），除了 callback 之外还可以接受 this 值（可选），用于执行 callback 函数时使用的 this 值。

> 来个简单的例子方便理解，现在有一个数组 [1, 2, 3, 4]，我们想要生成一个新数组，其每个元素皆是之前数组的两倍，那么我们有下面两种使用高阶和不使用高阶函数的方式来实现。

```
// 不使用高阶函数
const arr1 = [1, 2, 3, 4];
const arr2 = [];
for (let i = 0; i < arr1.length; i++) {
  arr2.push( arr1[i] * 2);
}

console.log( arr2 );
// [2, 4, 6, 8]
console.log( arr1 );
// [1, 2, 3, 4]
```

```
// 使用高阶函数
const arr1 = [1, 2, 3, 4];
const arr2 = arr1.map(item => item * 2);

console.log( arr2 );
// [2, 4, 6, 8]
console.log( arr1 );
// [1, 2, 3, 4]
```

> Array.prototype.filter
>
> filter() 方法创建一个新数组, 其包含通过提供函数实现的测试的所有元素，原始数组不会改变。接收的参数和 map 是一样的，其返回值是一个新数组、由通过测试的所有元素组成，如果没有任何数组元素通过测试，则返回空数组。

> 来个例子介绍下，现在有一个数组 [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]，我们想要生成一个新数组，这个数组要求没有重复的内容，即为去重。

```
//不使用高阶函数
const arr1 = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];
const arr2 = [];
for (let i = 0; i < arr1.length; i++) {
  if (arr1.indexOf( arr1[i] ) === i) {
    arr2.push( arr1[i] );
  }
}

console.log( arr2 );
// [1, 2, 3, 5, 4]
console.log( arr1 );
// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]
```

```
//使用高阶函数
const arr1 = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];
const arr2 = arr1.filter( (element, index, self) => {
    return self.indexOf( element ) === index;
});

console.log( arr2 );
// [1, 2, 3, 5, 4]
console.log( arr1 );
// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]
```

> Array.prototype.reduce
>
> reduce() 方法对数组中的每个元素执行一个提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。传递给 reduce 的回调函数（callback）接受四个参数，分别是累加器 accumulator、currentValue、currentIndex（可选）、array（可选），除了 callback 之外还可以接受初始值 initialValue 值（可选）。
>
> 如果没有提供 initialValue，那么第一次调用 callback 函数时，accumulator 使用原数组中的第一个元素，currentValue 即是数组中的第二个元素。 在没有初始值的空数组上调用 reduce 将报错。
>
> 如果提供了 initialValue，那么将作为第一次调用 callback 函数时的第一个参数的值，即 accumulator，currentValue 使用原数组中的第一个元素。
>
> 来个简单的例子介绍下，现在有一个数组 [0, 1, 2, 3, 4]，需要计算数组元素的和，需求比较简单，来看下代码实现。

```
//不使用高阶函数
const arr = [0, 1, 2, 3, 4];
let sum = 0;
for (let i = 0; i < arr.length; i++) {
  sum += arr[i];
}

console.log( sum );
// 10
console.log( arr );
// [0, 1, 2, 3, 4]
```

```
//使用高阶函数  无initialValue
const arr = [0, 1, 2, 3, 4];
let sum = arr.reduce((accumulator, currentValue, currentIndex, array) => {
  return accumulator + currentValue;
});

console.log( sum );
// 10
console.log( arr );
// [0, 1, 2, 3, 4]
```

```
//使用高阶函数  有initialValue
const arr = [0, 1, 2, 3, 4];
let sum = arr.reduce((accumulator, currentValue, currentIndex, array) => {
  return accumulator + currentValue;
}, 10);

console.log( sum );
// 20
console.log( arr );
// [0, 1, 2, 3, 4]
```

#### 2) 函数作为返回值输出

> isType 函数

我们知道在判断类型的时候可以通过 Object.prototype.toString.call 来获取对应对象返回的字符串，比如：

```

let isString = obj => Object.prototype.toString.call( obj ) === '[object String]';

let isArray = obj => Object.prototype.toString.call( obj ) === '[object Array]';

let isNumber = obj => Object.prototype.toString.call( obj ) === '[object Number]';

```

可以发现上面三行代码有很多重复代码，只需要把具体的类型抽离出来就可以封装成一个判断类型的方法了，代码如下。

```
let isType = type => obj => {
  return Object.prototype.toString.call( obj ) === '[object ' + type + ']';
}

isType('String')('123');		// true
isType('Array')([1, 2, 3]);	// true
isType('Number')(123);			// true
```

这里就是一个高阶函数，因为 isType 函数将 obj => { ... } 这一函数作为返回值输出。

> add 函数
> 我们看一个常见的面试题，用 JS 实现一个无限累加的函数 add，示例如下

```
add(1); // 1
add(1)(2);  // 3
add(1)(2)(3)； // 6
add(1)(2)(3)(4)； // 10
```

我们可以看到结构和上面代码有些类似，都是将函数作为返回值输出，然后接收新的参数并进行计算。

我们知道打印函数时会自动调用 toString()方法，函数 add(a) 返回一个闭包 sum(b)，函数 sum() 中累加计算 a = a + b，只需要重写 sum.toString()方法返回变量 a 就可以了。

```
function add(a) {
    function sum(b) { // 使用闭包
    	a = a + b; // 累加
    	return sum;
    }
    sum.toString = function() { // 重写toString()方法
        return a;
    }
    return sum; // 返回一个函数
}

add(1); // 1
add(1)(2);  // 3
add(1)(2)(3)； // 6
add(1)(2)(3)(4)； // 10
```

### 2、[函数柯里化](https://github.com/yygmind/blog/issues/37)

> 定义
>
> 函数柯里化又叫部分求值，维基百科中对柯里化 (Currying) 的定义为：
>
> > 在数学和计算机科学中，柯里化是一种将使用多个参数的函数转换成一系列使用一个参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术。
>
> 用大白话来说就是只传递给函数一部分参数来调用它，让它返回一个新函数去处理剩下的参数。使用一个简单的例子来介绍下，最常用的就是 add 函数了。

```
// 木易杨
const add = (...args) => args.reduce((a, b) => a + b);

// 传入多个参数，执行 add 函数
add(1, 2) // 3

// 假设我们实现了一个 currying 函数，支持一次传入一个参数
let sum = currying(add);
// 封装第一个参数，方便重用
let addCurryOne = sum(1);
addCurryOne(2) // 3
addCurryOne(3) // 4
```

> 实际应用

#### 1）延迟计算

```
// 木易杨
const add = (...args) => args.reduce((a, b) => a + b);

// 简化写法
function currying(func) {
    const args = [];
    return function result(...rest) {
        if (rest.length === 0) {
          return func(...args);
        } else {
          args.push(...rest);
        	return result;
        }
    }
}

const sum = currying(add);

sum(1,2)(3); // 未真正求值
sum(4); 		 // 未真正求值
sum(); 			 // 输出 10
```

上面的代码理解起来很容易，就是「用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数」。上面的 currying 函数是一种简化写法，判断传入的参数长度是否为 0，若为 0 执行函数，否则收集参数。

```
// 木易杨
let obj = {
  name: 'muyiy'
}
const fun = function () {
  console.log(this.name);
}.bind(obj);

fun(); // muyiy
```

#### 2) 动态创建函数

有一种典型的应用情景是这样的，每次调用函数都需要进行一次判断，但其实第一次判断计算之后，后续调用并不需要再次判断，这种情况下就非常适合使用柯里化方案来处理。即第一次判断之后，动态创建一个新函数用于处理后续传入的参数，并返回这个新函数。当然也可以使用惰性函数来处理，本例最后一个方案会有所介绍。

我们看下面的这个例子，在 DOM 中添加事件时需要兼容现代浏览器和 IE 浏览器（IE < 9），方法就是对浏览器环境进行判断，看浏览器是否支持，简化写法如下。

```
// 简化写法
function addEvent (type, el, fn, capture = false) {
    if (window.addEventListener) {
        el.addEventListener(type, fn, capture);
    }
    else if(window.attachEvent){
        el.attachEvent('on' + type, fn);
    }
}
```

但是这种写法有一个问题，就是每次添加事件都会调用做一次判断，那么有没有什么办法只判断一次呢，可以利用闭包和立即调用函数表达式（IIFE）来处理。

```
const addEvent = (function(){
    if (window.addEventListener) {
        return function (type, el, fn, capture) {
            el.addEventListener(type, fn, capture);
        }
    }
    else if(window.attachEvent){
        return function (type, el, fn) {
            el.attachEvent('on' + type, fn);
        }
    }
})();
```

上面这种实现方案就是一种典型的柯里化应用，在第一次的 if...else if... 判断之后完成部分计算，动态创建新的函数用于处理后续传入的参数，这样做的好处就是之后调用就不需要再次计算了。

#### 3)参数复用 -- 参考 isType 函数

### 实现 currying 函数

我们可以理解所谓的柯里化函数，就是封装「一系列的处理步骤」，通过闭包将参数集中起来计算，最后再把需要处理的参数传进去。那如何实现 currying 函数呢？

实现原理就是「用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数」。上面延迟计算部分已经实现了一个简化版的 currying 函数。

下面我们来实现一个更加健壮的的 currying 函数。

```
function currying(fn, length) {
  length = length || fn.length; 	// 注释 1
  return function (...args) {			// 注释 2
    return args.length >= length	// 注释 3
    	? fn.apply(this, args)			// 注释 4
      : currying(fn.bind(this, ...args), length - args.length) // 注释 5
  }
}

// Test
const fn = currying(function(a, b, c) {
    console.log([a, b, c]);
});

fn("a", "b", "c") // ["a", "b", "c"]
fn("a", "b")("c") // ["a", "b", "c"]
fn("a")("b")("c") // ["a", "b", "c"]
fn("a")("b", "c") // ["a", "b", "c"]

//注释 1：第一次调用获取函数 fn 参数的长度，后续调用获取 fn 剩余参数的长度

//注释 2：currying 包裹之后返回一个新函数，接收参数为 ...args

//注释 3：新函数接收的参数长度是否大于等于 fn 剩余参数需要接收的长度

//注释 4：满足要求，执行 fn 函数，传入新函数的参数

//注释 5：不满足要求，递归 currying 函数，新的 fn 为 bind 返回的新函数（bind 绑定了 ...args 参数，未执行），新的 length 为 fn 剩余参数的长度
```

## 九、[一名【合格】前端工程师的自检清单](https://juejin.im/post/5cc1da82f265da036023b628)

### 笔记

### 1.this 的几种使用场景

JavaScript 中的 this 含义要丰富得多，它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。JavaScript 中函数的调用有以下几种方式：
作为对象方法调用
作为函数调用
作为构造函数调用
使用 apply 或 call,bind 调用
下面我们将按照调用方式的不同，分别讨论 this 的含义。

> 1、作为对象方法调用
>
> 在 JavaScript 中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方式时，this 被自然绑定到该对象

```

var test = {
a:1,
b:0,
get:function(){
return this.a;
}
}
test.get()//1

```

> 2.作为函数调用
>
> 函数也可以直接被调用，此时 this 绑定到全局对象。在浏览器中，window 就是该全局对象。比如下面的例子：函数被调用时，this 被绑定到全局对象，接下来执行赋值语句，相当于隐式的声明了一个全局变量，这显然不是调用者希望的

```

function makeNoSense(x) {
this.x = x;
}

```

> 3.作为构造函数调用
>
> javaScript 支持面向对象式编程，与主流的面向对象式编程语言不同，JavaScript 并没有类（class）的概念，而是使用基于原型（prototype）的继承方式。相应的，JavaScript 中的构造函数也很特殊，如果不使用 new 调用，则和普通函数一样。作为又一项约定俗成的准则，构造函数以大写字母开头，提醒调用者使用正确的方式调用。如果调用正确，this 绑定到新创建的对象上。

```

function Point(x, y){
this.x = x;
this.y = y;
}

```

> 当应用于内部函数，即声明在另外一个函数体内的函数，这种绑定到全局对象的方式会产生另外一个问题。我们仍然以前面提到的 point 对象为例，这次我们希望在 moveTo 方法内定义两个函数，分别将 x，y 坐标进行平移。结果可能出乎大家意料，不仅 point 对象没有移动，反而多出两个全局变量 x，y。

```

var point = {
x : 0,
y : 0,
moveTo : function(x, y) {
// 内部函数
var moveX = function(x) {
this.x = x;//this 绑定到了哪里？
};
// 内部函数
var moveY = function(y) {
this.y = y;//this 绑定到了哪里？
};

    moveX(x);
    moveY(y);
    }

};
point.moveTo(1, 1);
point.x; //==>0
point.y; //==>0
x; //==>1
y; //==>1

```

> 这属于 JavaScript 的设计缺陷，正确的设计方式是内部函数的 this 应该绑定到其外层函数对应的对象上，为了规避这一设计缺陷，聪明的 JavaScript 程序员想出了变量替代的方法，约定俗成，该变量一般被命名为 that。

```

var point = {
x : 0,
y : 0,
moveTo : function(x, y) {
var that = this;
// 内部函数
var moveX = function(x) {
that.x = x;
};
// 内部函数
var moveY = function(y) {
that.y = y;
}
moveX(x);
moveY(y);
}
};
point.moveTo(1, 1);
point.x; //==>1
point.y; //==>1

```

> 4.在 call 或者 apply，bind 中调用
>
> 让我们再一次重申，在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。很多 JavaScript 中的技巧以及类库都用到了该方法。让我们看一个具体的例子
>
> 当一个函数被 call、apply 或者 bind 调用时，this 的值就取传入的对象的值。

```

var obj = {
x: 10
}
function foo(){
console.log(this); //{x: 10}
console.log(this.x); //10
}
foo.call(obj);
foo.apply(obj);
foo.bind(obj)();

```

> 5.箭头函数中的 this
>
> 当使用箭头函数的时候，情况就有所不同了：箭头函数内部的 this 是词法作用域，由上下文确定。
>
> 现在，箭头函数完全修复了 this 的指向，this 总是指向词法作用域，也就是外层调用者 obj。

```

var obj = {
x: 10,
foo: function() {
var fn = () => {
return () => {
return () => {
console.log(this); //Object {x: 10}
console.log(this.x); //10
}
}
}
fn()()();
}
}
obj.foo();

```

## 十、[前端面试每日 3+1](https://github.com/haizlin/fe-interview)

## 十一、[webpack 教程](https://juejin.im/user/5ac0e63e6fb9a028cb2dc4c0/posts)--大有收货很详细

[全面的文档](https://juejin.im/post/5d2d336951882543b7223307)

### 目前版本的主要特性

目前最新的版本是 v4.32.2，webpack4 升级之后，增加了很多新特性

- 不在支持 Node.js 4
- 移除 CommonChunkPlugin，增加 optimization
- 支持 WebAssembly
- 支持多种模块类型
- 增加 mode 配置
- 零配置模块打包
- 更快的构建时间，速度提升了 98%

### 配置

1. entry
2. output
3. mode
4. loaders
5. plugins

## 十二、[一次完整的面试过程](https://juejin.im/post/5d282541e51d4577523f2422)

## 十三、[设计模式](https://www.cnblogs.com/imwtr/p/9451129.html)

### 一、单例模式

定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点

核心：确保只有一个实例，并提供全局访问

实现：假设要设置一个管理员，多次调用也仅设置一次，我们可以使用闭包缓存一个内部变量来实现这个单例

```
function SetManager(name) {
    this.manager = name;
}

SetManager.prototype.getName = function() {
    console.log(this.manager);
};

var SingletonSetManager = (function() {
    var manager = null;

    return function(name) {
        if (!manager) {
            manager = new SetManager(name);
        }

        return manager;
    }
})();

SingletonSetManager('a').getName(); // a
SingletonSetManager('b').getName(); // a
SingletonSetManager('c').getName(); // a
```

### 二、策略模式

1. 定义

定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。

2. 核心

将算法的使用和算法的实现分离开来。

一个基于策略模式的程序至少由两部分组成：

第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。

第二个部分是环境类 Context，Context 接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明 Context 中要维持对某个策略对象的引用

3. 实现

策略模式可以用于组合一系列算法，也可用于组合一系列业务规则

假设需要通过成绩等级来计算学生的最终得分，每个成绩等级有对应的加权值。我们可以利用对象字面量的形式直接定义这个组策略

在组合业务规则方面，比较经典的是表单的验证方法。

```
// 加权映射关系
var levelMap = {
    S: 10,
    A: 8,
    B: 6,
    C: 4
};

// 组策略
var scoreLevel = {
    basicScore: 80,

    S: function() {
        return this.basicScore + levelMap['S'];
    },

    A: function() {
        return this.basicScore + levelMap['A'];
    },

    B: function() {
        return this.basicScore + levelMap['B'];
    },

    C: function() {
        return this.basicScore + levelMap['C'];
    }
}

// 调用
function getScore(level) {
    return scoreLevel[level] ? scoreLevel[level]() : 0;
}

console.log(
    getScore('S'),
    getScore('A'),
    getScore('B'),
    getScore('C'),
    getScore('D')
); // 90 88 86 84 0
```

4. 优缺点

优点

可以有效地避免多重条件语句，将一系列方法封装起来也更直观，利于维护

缺点

往往策略集会比较多，我们需要事先就了解定义好所有的情况

### 三、代理模式

1. 定义

为一个对象提供一个代用品或占位符，以便控制对它的访问

2. 核心

当客户不方便直接访问一个 对象或者不满足需要的时候，提供一个替身对象 来控制对这个对象的访问，客户实际上访问的是 替身对象。

替身对象对请求做出一些处理之后， 再把请求转交给本体对象

代理和本体的接口具有一致性，本体定义了关键功能，而代理是提供或拒绝对它的访问，或者在访问本体之前做一 些额外的事情

3. 实现

代理模式主要有三种：保护代理、虚拟代理、缓存代理

> 保护代理主要实现了访问主体的限制行为，以过滤字符作为简单的例子

```
// 主体，发送消息
function sendMsg(msg) {
    console.log(msg);
}

// 代理，对消息进行过滤
function proxySendMsg(msg) {
    // 无消息则直接返回
    if (typeof msg === 'undefined') {
        console.log('deny');
        return;
    }

    // 有消息则进行过滤
    msg = ('' + msg).replace(/泥\s*煤/g, '');

    sendMsg(msg);
}


sendMsg('泥煤呀泥 煤呀'); // 泥煤呀泥 煤呀
proxySendMsg('泥煤呀泥 煤'); // 呀
proxySendMsg(); // deny
```

它的意图很明显，在访问主体之前进行控制，没有消息的时候直接在代理中返回了，拒绝访问主体，这数据保护代理的形式

> 虚拟代理在控制对主体的访问时，加入了一些额外的操作

在滚动事件触发的时候，也许不需要频繁触发，我们可以引入函数节流，这是一种虚拟代理的实现

```
// 函数防抖，频繁操作中不处理，直到操作完成之后（再过 delay 的时间）才一次性处理
function debounce(fn, delay) {
    delay = delay || 200;

    var timer = null;

    return function() {
        var arg = arguments;

        // 每次操作时，清除上次的定时器
        clearTimeout(timer);
        timer = null;

        // 定义新的定时器，一段时间后进行操作
        timer = setTimeout(function() {
            fn.apply(this, arg);
        }, delay);
    }
};

var count = 0;

// 主体
function scrollHandle(e) {
    console.log(e.type, ++count); // scroll
}

// 代理
var proxyScrollHandle = (function() {
    return debounce(scrollHandle, 500);
})();

window.onscroll = proxyScrollHandle;
```

> 缓存代理可以为一些开销大的运算结果提供暂时的缓存，提升效率

```
/ 主体
function add() {
    var arg = [].slice.call(arguments);

    return arg.reduce(function(a, b) {
        return a + b;
    });
}

// 代理
var proxyAdd = (function() {
    var cache = [];

    return function() {
        var arg = [].slice.call(arguments).join(',');

        // 如果有，则直接从缓存返回
        if (cache[arg]) {
            return cache[arg];
        } else {
            var ret = add.apply(this, arguments);
            return ret;
        }
    };
})();

console.log(
    add(1, 2, 3, 4),
    add(1, 2, 3, 4),

    proxyAdd(10, 20, 30, 40),
    proxyAdd(10, 20, 30, 40)
); // 10 10 100 100
```

### 四、迭代器模式

1. 定义

迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。

2. 核心

在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素

3. 实现

JS 中数组的 map forEach 已经内置了迭代器

---

# 十四、笔记

## 1、移动端打开指定 App 或者下载 App

```
navToDownApp() {
      let u = navigator.userAgent
      if (/MicroMessenger/gi.test(u)) {
        // 如果是微信客户端打开，引导用户在浏览器中打开
        alert('请在浏览器中打开')
      }
      if (u.indexOf('Android') > -1 || u.indexOf('Linux') > -1) {
        // Android
        if (this.openApp('en://startapp')) {
          this.openApp('en://startapp') // 通过Scheme协议打开指定APP
        } else {
          //跳转Android下载地址
        }
      } else if (u.indexOf('iPhone') > -1) {
        if (this.openApp('ios--scheme')) {
          this.openApp('ios--scheme') // 通过Scheme协议打开指定APP
        } else {
          // 跳转IOS下载地址
        }
      }
    },
    openApp(src) {
      // 通过iframe的方式试图打开APP，如果能正常打开，会直接切换到APP，并自动阻止a标签的默认行为
      // 否则打开a标签的href链接
      let ifr = document.createElement('iframe')
      ifr.src = src
      ifr.style.display = 'none'
      document.body.appendChild(ifr)
      window.setTimeout(function() {
        // 打开App后移出这个iframe
        document.body.removeChild(ifr)
      }, 2000)
    }
```

## 2、如何优雅的处理图片异常

### 监听图片的 error 事件

缺点：确实实现了对异常图片的降级处理，但每张图片都需要通过 JS 进行获取，并且监听 error 事件，对于大量图片的情况并不适用

```
<img id="img" src="//xxx.xxx.xxx/img.png">
```

```
let img = document.getElementById('img');
img.addEventListener('error',function(e){
    e.target.str = '//xxx.xxx.xxx/default.png'; // 为当前图片设定默认图
})
```

### 内联事件来监听 error 事件

缺点：但这种方式还不够好，因为我们仍然需要手动的向 img 标签中添加内联事件，在实际开发过程中，很难保证每张图片都不漏写

```
<img src="//xxx.xxx.xxx/img.png" onerror="this.src = '//xxx.xxx.xxx/default.png'">
```

### 全局监听

我们希望的是，能够在全局监听 error 事件，在实际实现之前，先来看一下浏览器中的事件流
DOM2 级事件规定事件流包含三个阶段：

事件捕获阶段

处于目标阶段

事件冒泡阶段

首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到的事件。最后一个阶段是冒泡阶段。
我们上文中的监听图片自身的 error 事件，实际上在事件流中是处于目标阶段。
对于 img 的 error 事件来说，是无法冒泡的，但是是可以捕获的，我们的实现如下:

```
window.addEventListener('error',function(e){
    // 当前异常是由图片加载异常引起的
    if( e.target.tagName.toUpperCase() === 'IMG' ){
        e.target.src = '//xxx.xxx.xxx/default.jpg';
    }
},true)
```

最后，我们在思考一个问题，当网络出现异常的时候，必然会出现什么网络图片都无法加载的情况，这样就会导致我们监听的 error 事件
被无限触发，所以我们可以设定一个计数器，当达到期望的错误次数时停止对图片赋予默认图片的操作，改为提供一个 Base64 的图片
实现起来也很简单，如下：

```
window.addEventListener('error',function(e){
    let target = e.target, // 当前dom节点
        tagName = target.tagName,
        times = Number(target.dataset.times) || 0, // 以失败的次数，默认为0
        allTimes = 3; // 总失败次数，此时设定为3
    // 当前异常是由图片加载异常引起的
    if( tagName.toUpperCase() === 'IMG' ){
        if(times >= allTimes){
            target.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
        }else{
            target.dataset.times = times + 1;
            target.src = '//xxx.xxx.xxx/default.jpg';
        }
    }
},true)
```

## 3、不要给 async 函数写那么多 try/catch 了

在开发中，你是否会为了系统健壮性，亦或者是为了捕获异步的错误，而频繁的在 async 函数中写 try/catch 的逻辑？

```
async function func() {
    try {
        let res = await asyncFunc()
    } catch (e) {
      //......
    }
}
```

实现一个包裹函数

```
async function errorCaptured (asyncFunc) {
  tyr {
    let res = await asyncFunc()
    retutn [null,res]
  }catch(e){
    retutn [e,null]
  }
}
```

这样我们就可以使用一个辅助函数包裹这个 async 函数实现错误捕获

```

async function func() {
let [err, res] = await errorCaptured(asyncFunc)
if (err) {
//... 错误捕获
}
//...
}

```

## 4、异步加载 JS 脚本的方式有哪些？

> script 标签中增加 async(html5) 或者 defer(html4) 属性,脚本就会异步加载。

```
<script src="../XXX.js" defer></script>
```

defer 和 async 的区别在于：

- defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），在 window.onload 之前执行；

- async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。

- 如果有多个 defer 脚本，会按照它们在页面出现的顺序加载

- 多个 async 脚本不能保证加载顺序

> 动态创建 script 标签

动态创建的 script ，设置 src 并不会开始下载，而是要添加到文档中，JS 文件才会开始下载。

> XHR 异步加载 JS

## 5、http 协议、https 协议

### 描述网页从输入 url 到渲染的过程

1. 首先获取 url 解析出 ip 地址 如果本地 hosts 中有配置优先取出配置 若没有则进行 dns 解析
2. tcp 三次挥手 建立连接
3. 客户端发送 http 请求
4. 服务器处理请求并响应
5. 浏览器处理资源文件进行渲染
6. tcp 的四次挥手

### 简述三次握手和四次挥手

> 三次握手

第一次握手：客户端采用 TCP 协议将带有 SYN 标志的数据包发送给服务器，等待服务器的确认。

第二次握手：服务器端在收到 SYN 的数据包后，必须确认 SYN，并发送的 ACK 标志，同时，自己也将会向客户端发送一个 SYN 标志。

第三次握手：客户端在接收到服务器段的 SYN+ACK 包后，自己会向服务器发送 ACK 包，完成三次握手。那么客户端和服务器正式建立了连接，开始传输数据。

> 四次挥手

1. 当客户端的数据传输到尾部时，客户端向服务器发送带有 FIN 标志的数据包，使其明白自己准备断开通信了。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。

2. 因为 TCP 的通信是使用全双工通信的，所以在断开连接的时候也应该是双向的；当服务器收到带有 FIN 标志的数据包时，
   其必不会直接发送 FIN 标志断开通信的请求，而是先发送一个带有 ACK 标志的应答信息，使客户端明白服务器还有数据要进行发送。

3. 服务器的数据发送完成后，向客户端发送带有 FIN 标志的数据包，通知客户端断开连接。

4. 当客户端收到 FIN 后，担心某些不可控制的因素导致服务器不知道他要断开连接，会发送 ACK 进行确认，同时把自己设置成 TIME_WAIT 状态并启动定时器，在 TCP 的定时器到达后客户端并没有接收到请求，会重新发送；当服务器收到请求后就断开连接；当客户端等待 2MLS（两倍报文最大生存时间）后，没有收到请求重传的请求后，客户端这边就断开连接，整个 TCP 通信就结束了。

> 为什么握手是三次，挥手是四次

因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。
但是关闭连接时，当 Server 端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文。
只有等到我 Server 端所有的报文都发送完了，才能发送 FIN 报文，因此不能一起发送。故需要四步握手。

> 为什么不能进行两次握手链接

如果是两次握手，在第二次结束后，服务器并不能保证客户端已经收到了第二次的请求，如此一来的话，服务器会一直保存着这个通信过程，
因为 TCP 通信都是要占用端口的，造成了一定的资源浪费。所以，就一定要让客户端来发送 ACK 的确认请求。

### https 的传输过程

1. 在服务器端存在一个公钥及私钥

2. 客户端从服务器取得这个公钥

3. 客户端产生一个随机的密钥

4. 客户端通过公钥对密钥加密（非对称加密）

5. 客户端发送到服务器端

6. 服务器端接受这个密钥并且以后的服务器端和客户端的数据全部通过这个密钥加密

### https 和 http 的区别

1. https 需要证书。

2. http 是超文本传输协议，是明文传输，https 则是具有安全性的 ssl 加密传输协议。

3. http 和 https 使用的端口不同，前者是 80，后者是 443。

4. http 的连接很简单，无状态；HTTPS 是由 SSL+HTTP 构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。

### 强制缓存和协商缓存

强制缓存是我们在第一次请求资源时在 http 响应头设置一个过期时间，在时效内都将直接从浏览器进行获取，
常见的 http 响应头字段如 Cache-Control 和 Expires

协商缓存是我们通过 http 响应头字段 etag 或者 Last-Modified 等判断服务器上资源是否修改，
如果修改则从服务器重新获取，如果未修改则 304 指向浏览器缓存中进行获取。

## 6、浅谈回流和重绘

> 页面的呈现流程

1. 浏览器将获取到的 html 文档解析成一个 Dom 树，html 中的每个元素都是 Dom 树中的一个节点，根节点就是 document。Dom 树中包含所有的 html 标签，包括 display:none，以及 js 动态添加的元素。
2. 浏览器将所有的 CSS 解析成样式结构，在解析过程中去掉浏览器不能识别的样式，比如 IE 去掉-moz-等开头的样式，Firefox 去掉\_等开头的样式。
3. 浏览器将 Dom 树和 CSS 的样式结构体组合后生成 Render Tree。Render Tree 类似于 Dom Tree，但有很大的区别。Render Tree 能够识别样式，每个节点都有自己的样式，并且不包含隐藏节点（例如 display:none 和 head 等），但是 visibility:hidden 会包含在 Render Tree 中，因为 visibility:hidden 会影响页面的布局，会占空间。
4. Render Tree 构建完成之后，浏览器根据 Render Tree 开始绘制页面。

> 重绘和回流

回流：当 Render Tree 中的元素因为布局、尺寸、隐藏等改变需要重新构建，就称为回流。每个页面至少回流一次，就是在页面一次加载的时候。完成回流后，浏览器会重新绘制受影响的部分到屏幕中。

重绘：在页面中的元素需要更新一些背景等影响外观的样式，而不绘影响布局的属性时，就称为重绘。

注意：回流必将引起重绘，而重绘不一定会引起回流。

> 回流的原因

1. Dom 操作；
2. 调整窗口大小；
3. 元素位置或尺寸改变——边距、填充、边框、宽度和高度；
4. 字体大小改变；
5. 页面渲染的初始化
6. 元素内容变化，尤其是输入控件；
7. 请求了 getComputedStyle(), 或者 IE 的 currentStyle，或 offsetWidth, width, clientWidth, scrollTop/scrollHeight 的计算。

> 减少回流、重绘

1. 避免逐项改变样式，最好一次性改变样式属性。或者将样式定义成 class 进行一次性修改。
2. 避免直接操作 Dom，创建一个 documentFragment 或 div，在它上面进行 Dom 操作，只引发一到俩次回流和重绘。也可以使用 cloneNode(true or false) 和 replaceChild 技术，只引发一次回流和重绘。
3. 避免循环读取 offsetTop 等属性。
4. 绝对定位具有复杂动画的元素。绝对定位使它脱离文档刘，否则会引起父元素及后续元素大量的回流。

> 浏览器的优化

回流会增加很多的开销，如果每句 Js 都进行一次回流和重绘的话，浏览器会受不了，所以很多浏览器都会优化这些操作。浏览器会维护一个队列，所有的回流和重绘放入到这个队列中，等队列到达一定的数量或到一定的时间间隔，浏览器就会 flush 队列，将队列中的操作进行一次批处理，这样就将一个多次回流和重绘合并成了一次。

虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前 flush 队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style 信息的时候，就会让浏览器 flush 队列，比如：

1. offsetTop, offsetLeft, offsetWidth, offsetHeight
2. scrollTop/Left/Width/Height
3. clientTop/Left/Width/Height
4. width,height
5. 请求了 getComputedStyle(), 或者 IE 的 currentStyle

当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要 flush 队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。

## 7、前端安全方面

### xss 攻击原理

第一、XSS 反射型攻击，恶意代码并没有保存在目标网站，通过引诱用户点击一个链接到目标网站的恶意链接来实施攻击的。

第二、XSS 存储型攻击，恶意代码被保存到目标网站的服务器中，这种攻击具有较强的稳定性和持久性。

解决方案 1. url 过滤 2.提交的符号如<>（尖括号）、”（引号）、 ‘（单引号）、%（百分比符号）、;
（分号）、()（括号）、&（& 符号）、+（加号）等转义。严格控制输出

### CSRF 跨站请求伪造

CSRF 指的是攻击者盗用了你的身份,以你的名义发送恶意的请求,给你造成个人隐私泄露及财产安全.通常指携带你的 ck 进行请求一些链接。

解决方案

添加 refer 改用 token

## 8、性能优化方面

### webpack 优化

1. 外部引入模块(CDN)
2. 按需引入
3. tree-shaking
4. 开启 gzip

### 其余的优化

1. 前面提到的强制缓存与协商缓存
2. 减少不必要的 http 请求 对资源进行合并
3. 使用骨架屏提升用户体验
4. 前面提到的 defer 延迟加载
5. 懒加载

## 9、[CSS 开发必知必会的 16 个调试工具技巧](https://juejin.im/post/5d39d27cf265da1bc14b6f47)--很厉害

## 10、[如何优雅处理前端异常？](http://jartto.wang/2018/11/20/js-exception-handling/index.html)

## 11、webpack 样式 常用包

### css-loader

当匹配到 css 文件时，就要用 css-loader 对 css 样式进行处理

css-loader 会处理 css 的资源，当它遇到一个 url 的时候，css-loader 会帮助我们处理 url 里面的东西，当出现 url，css-loader 就会知道，可能要加载一些东西，要引入一些东西，这时，css-loader 会帮助你去引入这个模块，之后 webpack 会帮助你处理这个模块

### style-loader

当有样式被打包到我们的入口文件时，style-loader 会把打包的样式插入到我们的 HTML 结构中

```
{
  test:/\.css$/,
  use:['style-loader','css-loader'],
}
```

use 中的 style-loader 和 css-loader 顺序不能变，因为 loader 的处理有一个优先级，从右到左、从下到上

很显然，只有当我们对 css 文件进行处理打包之后才将其插入到 HTML 结构中，所以要 css-loader 在右侧，style-loader 在左侧

### file-loader

专门处理图片

file-loader 主要做了两件事：1、把 url 里面内容转换成我们最终需要使用的那个路径。2、把图片转移到我们输出的目录，并且把图片更改为另外一种名字或者做一些其他的处理

```

import dog  from './common/imgs/dog.jpg'

ReactDOM.render(
    <div><img src={dog}/></div>,
document.getElementById('root')

 );
```

当我们在模块里面使用 import 来引入一个图片资源的时候，file-loader 也会把这个图片移动到你的输出目录，给它更改一个名字，然后返回一个最终要加载的图片的一个路径

在 css 的背景图片和 HTML 结构中插入的图片，两者的不同是：在 HTML 中插入图片需要自己手动引入一个图片资源，然后 webpack 会帮助你引入这个模块（资源），引入这个资源的时候，file-loader 会帮助你做相应的处理，而在 css 文件中，直接是正常的写法即可，不需要自己去手动 import 一个文件资源，因为 css-loader 在遇到 url 时，会帮助你处理 url 中的内容，它在处理时，就会帮你引入了这个图片资源，然后用 file-loader 来处理这个图片资源

### url-loader

引入图片，可以说它是 file-loader 的增强版

url-loader 会把我们的图片使用 base64 的形式编码成另外一种字符串，网页是可以识别这种编码的东西的，这样的好处是，它减少了图片的请求，你只要请求回了这个页面，图片也就过来了，可以减少网络的请求，但是如果图片过大，这个字符串就会变得特变大，让加载的文件变得特别大

所以如果图片很小，没必要让其重新请求图片，直接将其写进页面中，让浏览器去解析，当图片过大时，就不让他编码，看下面的实现过程

```
{
                test:/\.jpg|gif|png$/,
                use:[{
                    loader:'url-loader',
                    options:{
                        limit:10000//以bit为单位，当小于10000bit时，编码，大于10000bit时，不编码
                    }
                }]，
            }
```

总结：当使用 url-loader 去处理一些资源的时候，默认会把所有的资源都是用 base64 的形式进行编码，但是我们可以给它一个 limit 属性去约束他，当资源小于某个值的时候，才去编码，当不小于这个值时，它其实是会把这个资源交个 file-loader 去处理

### postcss-loader

加载 node_moduels 中的 CSS 之前还要使用 postcss-loader 再统一处理一遍，以确保所有进入生产环境的 CSS 都经过了相应的浏览器兼容性处理。

## 12、webpack js 常用 loader

### babel-loader

告诉 webpack 我想要对我的 js 代码进行兼容性编译
具体配置文件可以新建新建.babelrc, 通过配置一些参数配合 webpack 进行打包压缩

```
"babel-core": "^6.26.3",
"babel-eslint": "^8.2.6",
"babel-loader": "^7.1.5",
"babel-plugin-module-resolver": "^3.1.1",
"babel-plugin-syntax-dynamic-import": "^6.18.0",
"babel-plugin-transform-class-properties": "^6.24.1",
"babel-plugin-transform-object-rest-spread": "^6.23.0",
"babel-preset-env": "^1.7.0",
"babel-preset-react": "^6.24.1",
```

这里放出推荐配置

```
{
  "sourceMaps": true,
  "presets": [
    "env",
    "react"
  ],
  "plugins": [
    "syntax-dynamic-import",
    "transform-class-properties",
    "transform-object-rest-spread",
    ["module-resolver", {
      "root": ["./src"]
    }]
  ]
}
```

> presets

### babel-preset-env

之前配置话需要很多例如 babel-preset-es2015, babel-preset-es2016 或者 stage-0
但是现在只需要 babel-preset-env 就可以解决

### babel-preset-react

用于解析 jsx

> plugin

### syntax-dynamic-import

允许解析 import()

### transform-class-properties

用于解决 es6 的 class 的 defaultProps={} 不支持的问题

### transform-object-rest-spread

允许 Babel transform rest 属性用于对象的解构和对象的自变量.
