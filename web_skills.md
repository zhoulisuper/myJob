# [一名【合格】前端工程师的自检清单](https://juejin.im/post/5cc1da82f265da036023b628)

## 一、JavaScript 基础

前端工程师吃饭的家伙，深度、广度一样都不能差。

### 变量和类型

#### 1. JavaScript 规定了几种语言类型

两种类型：基本类型和引用类型

6 种基本类型：String,Number,Boolean,Null,Undefined,Symbol

1 种引用类型：Object

#### 2. JavaScript 对象的底层数据结构是什么

如对象、数组、函数等，它们是通过拷贝和 new 出来的。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。

#### 3. Symbol 类型在实际开发中的应用、可手动实现一个简单的 Symbol

#### 4. JavaScript 中的变量在内存中的具体存储形式

基本类型是保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，通过按值访问

引用类型是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript 不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用

#### 5. 基本类型对应的内置对象，以及他们之间的装箱拆箱操作

内置对象：String（）、Number（）、Boolean（）、RegExp（）、Date（）、Error()、Array（）、

Function（）、Object（）、symbol（）;类似于对象的构造函数

在 JavaScript 中，有时会碰到以下两种类型的代码

```
var num = 123;
 var str = '123';
 num.toFixed(2); // '123.00'
 str.split(''); // ['1','2','3']
```

```
 var num = [1,2,3];
var str = {
      name:'hahaha'
};
console.log(num+1); //1,2,31
String(str); //'[object Object]'

```

在第一段代码中，我们在两个基本类型的值上调用方法。众所周知，在 JavaScript 中只有 Object 类型才有方法。在第二段代码中，我们可以把两个 Object 类型的值当做基本类型的值直接使用。这就是 JavaScript 装箱与拆箱在代码中的具体体现。
下面我分别来解释一下 JavaScript 中的装箱与拆箱。

#### 装箱

所谓装箱，就是把基本类型转变为对应的对象。装箱分为隐式和显示。

> 隐式装箱

每当读取一个基本类型的值时，后台会创建一个该基本类型所对应的对象。在这个基本类型上调用方法，其实是在这个基本类型对象上调用方法。这个基本类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立刻被销毁。具体到代码如下：

```
 num.toFixed(2); // '123.00'
//上方代码在后台的真正步骤为
    var c = new Number(123);
    c.toFixed(2);
    c = null;
```

当我们访问 num 时，要从内存中读取这个数字的值，此时访问过程处于读取模式。在读取模式中，后台进行了三步处理：

- 创建一个 Number 类型的实例。
- 在实例上调用方法。
- 销毁实例。

> 显式装箱

通过内置对象 Boolean、Object、String 等可以对基本类型进行显示装箱。

```
var obj = new String('123');
```

#### 拆箱

拆箱与装箱相反，把对象转变为基本类型的值。拆箱过程内部调用了抽象操作 ToPrimitive 。该操作接受两个参数，第一个参数是要转变的对象，第二个参数 PreferredType 是对象被期待转成的类型。第二个参数不是必须的，默认该参数为 number，即对象被期待转为数字类型。有些操作如 String(obj) 会传入 PreferredType 参数。有些操作如 obj + " " 不会传入 PreferredType。

具体转换过程是这样的。默认情况下，ToPrimitive 先检查对象是否有 valueOf 方法，如果有则再检查 valueOf 方法是否有基本类型的返回值。如果没有 valueOf 方法或 valueOf 方法没有返回值，则调用 toString 方法。如果 toString 方法也没有返回值，产生 TypeError 错误。

PreferredType 影响 valueOf 与 toString 的调用顺序。如果 PreferrenType 的值为 string。则先调用 toString ,再调用 valueOf。

```
var obj = {
    valueOf : () => {console.log("valueOf"); return []},
    toString : () => {console.log("toString"); return []}
}

String(obj)
// toString
// valueOf
// Uncaught TypeError: Cannot convert object to primitive value

obj+' '
//valueOf
//toString
// Uncaught TypeError: Cannot convert object to primitive value

Number(obj)
//valueOf
//toString
// Uncaught TypeError: Cannot convert object to primitive value
```

#### 6. 理解值类型和引用类型

（1）值类型：

1. 占用空间固定，保存在栈中（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。）
2. 保存与复制的是值本身
3. 使用 typeof 检测数据的类型
4. 基本类型数据是值类型

（2）引用类型：

1. 占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。）
2. 保存与复制的是指向对象的一个指针
3. 使用 instanceof 检测数据类型
4. 使用 new()方法构造出的对象是引用型

#### 7. null 和 undefined 的区别

null 表示空对象指针，将 null 赋值给变量，就表示该变量指向空对象
undefined 表示未定义，声明一个变量但不初始化，那么它的值就是 undefined
null 主要表示一个变量还没有真正保存对象的时候，它的值就应该为 null，这是意料之中的空，而 undefined 通常表示意料之外的内容，如未初始化的变量，一般来说我们不应该显式的使用 undefined

#### 8. 至少可以说出三种判断 JavaScript 数据类型的方式，以及他们的优缺点，如何准确的判断数组类型

Object.prototype.toString.call()

instanceof

isArray

#### 9. 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用

js 的数据类型隐式转换主要分为三种情况:

1. 转换为 boolean 类型
2. 转换为 number 类型
3. 转换为 string 类型

> 转换为 boolean 类型

数据在 逻辑判断 和 逻辑运算 之中会隐式转换为 boolean 类型

注意:如果使用 new 操作符创建的对象隐式转换为 boolean 类型都是 true，哪怕是 new String(”);

提示:连续使用两个非操作符(!!)可以将一个数强制转换为 boolean 类型，这在开发之中比较实用。

> 转换为 string 类型和转换为 number 类型

我将这两个放在一起总结是因为一个数到底转换为 string 还是 number 受到运行环境和操作符的影响，而不像上面转换为 boolean 类型这么固定。

> 先说运行环境对数据类型隐式转换的影响

很多内置函数期望传入的参数的数据类型是固定的，如:alert(value)方法，它期望传入的 value 值是一个 string 类型，但是如果我们传入的是 number 类型或者 object 类型等非 string 类型的数据的时候，就会发生数据类型的隐式转换。这就是环境运行环境对数据类型转换的影响。

> 操作符也会影响数据的类型转换

- 当+号作为一元操作符操作单操作数的时候，他就会将这个数转换为数字类型
- 当+号作为二元操作符时，如果两个操作数中存在一个字符类型的话，那么另外一个操作数也会无条件地转换为字符串
- 当+号作为二元操作符时，如果两个操作数一个都不是字符串的话，两个操作数会隐式转换成数字类型(如果无法成功转换成数字，则变成 NaN，再往下操作)，再进行加法算数操作
- 当算数运算的操作符是+号以外的其他操作数时，两个操作数都会转成数字类型进行数字运算。

> 数据类型如何转换成 string 类型或者 number 类型

数据类型转换成字符串或者数字都会遵循一个原则:如果该数据是简单数据类型，则直接转换成字符串或者数字类型。如果该数据是复杂数据类型，那么先通过固定的方法将复杂值转换为简单数据(拆箱)，再转成字符串或者数字。

#### 10. 出现小数精度丢失的原因，JavaScript 可以存储的最大数字、最大安全数字，JavaScript 处理大数字的方法、避免精度丢失的方法

#### 原因

计算机的二进制实现和位数限制有些数无法有限表示。就像一些无理数不能有限表示，如 圆周率 3.1415926...，1.3333... 等。JS 遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。

- 1 位用来表示符号位
- 11 位用来表示指数
- 52 位表示尾数

浮点数 0.1 >> 0.0001 1001 1001 1001…（1001 无限循环）

此时只能模仿十进制进行四舍五入了，但是二进制只有 0 和 1 两个，于是变为 0 舍 1 入。这即是计算机中部分浮点数运算时出现误差，丢失精度的根本原因。

大整数的精度丢失和浮点数本质上是一样的，尾数位最大是 52 位，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，十进制即 9007199254740992。大于 9007199254740992 的可能会丢失精度

#### 解决方法

解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）

---

### 原型和原型链

#### 1. 理解原型设计模式以及 JavaScript 中的原型规则

#### 2. instanceof 的底层实现原理，手动实现一个 instanceof

#### 3. 实现继承的几种方式以及他们的优缺点

#### 4. 至少说出一种开源项目(如 Node)中应用原型继承的案例

#### 5. 可以描述 new 一个对象的详细过程，手动实现一个 new 操作符

#### 6. 理解 es6 class 构造以及继承的底层实现原理

### 作用域和闭包

#### 1. 理解词法作用域和动态作用域

#### 2. 理解 JavaScript 的作用域和作用域链

#### 3. 理解 JavaScript 的执行上下文栈，可以应用堆栈信息快速定位问题

#### 4. this 的原理以及几种不同使用场景的取值

#### 5. 闭包的实现原理和作用，可以列举几个开发中闭包的实际应用

#### 6. 理解堆栈溢出和内存泄漏的原理，如何防止

#### 7. 如何处理循环的异步操作

#### 8. 理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理

### 执行机制

#### 1. 为何 try 里面放 return，finally 还会执行，理解其内部机制

#### 2. JavaScript 如何实现异步编程，可以详细描述 EventLoop 机制

#### 3. 宏任务和微任务分别有哪些

#### 4. 可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法

#### 5. 使用 Promise 实现串行

#### 6. Node 与浏览器 EventLoop 的差异

#### 7. 如何在保证页面运行流畅的情况下处理海量数据

### 语法和 API

#### 1. 理解 ECMAScript 和 JavaScript 的关系

#### 2. 熟练运用 es5、es6 提供的语法规范，

#### 3. 熟练掌握 JavaScript 提供的全局对象（例如 Date、Math）、全局函数（例如 decodeURI、isNaN）、全局属性（例如 Infinity、undefined）

#### 4. 熟练应用 map、reduce、filter 等高阶函数解决问题

#### 5. setInterval 需要注意的点，使用 settimeout 实现 setInterval

#### 6. JavaScript 提供的正则表达式 API、可以使用正则表达式（邮箱校验、URL 解析、去重等）解决常见问题

#### 7. JavaScript 异常处理的方式，统一的异常处理方案

## 二、HTML 和 CSS

### HTML

#### 1. 从规范的角度理解 HTML，从分类和语义的角度使用标签

#### 2. 常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式

#### 3. 元信息类标签(head、title、meta)的使用目的和配置方法

#### 4. HTML5 离线缓存原理

#### 5. 可以使用 Canvas API、SVG 等绘制高性能的动画

### CSS

#### 1. CSS 盒模型，在不同浏览器的差异

#### 2. CSS 所有选择器及其优先级、使用场景，哪些可以继承，如何运用 at 规则

#### 3. CSS 伪类和伪元素有哪些，它们的区别和实际应用

#### 4. HTML 文档流的排版规则，CSS 几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理

#### 5. 水平垂直居中的方案、可以实现 6 种以上并对比它们的优缺点

#### 6. BFC 实现原理，可以解决的问题，如何创建 BFC

#### 7. 可使用 CSS 函数复用代码，实现特殊效果

#### 8. PostCSS、Sass、Less 的异同，以及使用配置，至少掌握一种

#### 9. CSS 模块化方案、如何配置按需加载、如何防止 CSS 阻塞渲染

#### 10. 熟练使用 CSS 实现常见动画，如渐变、移动、旋转、缩放等等

#### 11. CSS 浏览器兼容性写法，了解不同 API 在不同浏览器下的兼容性情况

#### 12. 掌握一套完整的响应式布局方案

### 手写

#### 1. 手写图片瀑布流效果

#### 2. 使用 CSS 绘制几何图形（圆形、三角形、扇形、菱形等）

#### 3. 使用纯 CSS 实现曲线运动（贝塞尔曲线）

#### 4. 实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点

## 三、计算机基础

关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要

### 编译原理

#### 1. 理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序

#### 2. 正则表达式的匹配原理和性能优化

#### 3. 如何将 JavaScript 代码解析成抽象语法树(AST)

#### 4. base64 的编码原理

#### 5. 几种进制的相互转换计算方法，在 JavaScript 中如何表示和转换

### 网络协议

#### 1. 理解什么是协议，了解 TCP/IP 网络协议族的构成，每层协议在应用程序中发挥的作用

#### 2. 三次握手和四次挥手详细原理，为什么要使用这种机制

#### 3. 有哪些协议是可靠，TCP 有哪些手段保证可靠交付

#### 4. DNS 的作用、DNS 解析的详细过程，DNS 优化原理

#### 5. CDN 的作用和原理

#### 6. HTTP 请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么

#### 7. HTTP 所有状态码的具体含义，看到异常状态码能快速定位问题

#### 8. HTTP1.1、HTTP2.0 带来的改变

#### 9. HTTPS 的加密原理，如何开启 HTTPS，如何劫持 HTTPS 请求

#### 10. 理解 WebSocket 协议的底层原理、与 HTTP 的区别

### 设计模式

#### 1. 熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等

#### 2. 发布订阅模式和观察者模式的异同以及实际应用

#### 3. 可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用

## 四、数据结构和算法

据我了解的大部分前端对这部分知识有些欠缺，甚至抵触，但是，如果突破更高的天花板，这部分知识是必不可少的，而且我亲身经历——非常有用！

### JavaScript 编码能力

#### 1. 多种方式实现数组去重、扁平化、对比优缺点

#### 2. 多种方式实现深拷贝、对比优缺点

#### 3. 手写函数柯里化工具函数、并理解其应用场景和优势

#### 4. 手写防抖和节流工具函数、并理解其内部原理和应用场景

#### 5. 实现一个 sleep 函数

### 手动实现前端轮子

#### 1. 手动实现 call、apply、bind

#### 2. 手动实现符合 Promise/A+规范的 Promise、手动实现 async await

#### 3. 手写一个 EventEmitter 实现事件发布、订阅

#### 4. 可以说出两种实现双向绑定的方案、可以手动实现

#### 5. 手写 JSON.stringify、JSON.parse

#### 6. 手写一个模版引擎，并能解释其中原理

#### 7. 手写懒加载、下拉刷新、上拉加载、预加载等效果

### 数据结构

#### 1. 理解常见数据结构的特点，以及他们在不同场景下使用的优缺点

#### 2. 理解数组、字符串的存储原理，并熟练应用他们解决问题

#### 3. 理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题

#### 4. 了解图、堆的基本结构和使用场景

### 算法

#### 1. 可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗

#### 2. 至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度

#### 3. 了解递归和循环的优缺点、应用场景、并可在开发中熟练应用

#### 4. 可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题

#### 5. 前端处理海量数据的算法方案

## 五、运行环境

我们需要理清语言和环境的关系：

ECMAScript 描述了 JavaScript 语言的语法和基本对象规范

浏览器作为 JavaScript 的一种运行环境，为它提供了：文档对象模型（DOM），描述处理网页内容的方法和接口、浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口

Node 也是 JavaScript 的一种运行环境，为它提供了操作 I/O、网络等 API

### 浏览器 API

#### 1. 浏览器提供的符合 W3C 标准的 DOM 操作 API、浏览器差异、兼容性

#### 2. 浏览器提供的浏览器对象模型 (BOM)提供的所有全局 API、浏览器差异、兼容性

#### 3. 大量 DOM 操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame 等)

#### 4. 浏览器海量数据存储、操作性能优化

#### 5. DOM 事件流的具体实现机制、不同浏览器的差异、事件代理

#### 6. 前端发起网络请求的几种方式及其底层实现、可以手写原生 ajax、fetch、可以熟练使用第三方库

#### 7. 浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型

#### 8. 浏览器提供的几种存储机制、优缺点、开发中正确的选择

#### 9. 浏览器跨标签通信

### 浏览器原理

#### 1. 各浏览器使用的 JavaScript 引擎以及它们的异同点、如何在代码中进行区分

#### 2. 请求数据到请求结束与服务器进行了几次交互

#### 3. 可详细描述浏览器从输入 URL 到页面展现的详细过程

#### 4. 浏览器解析 HTML 代码的原理，以及构建 DOM 树的流程

#### 5. 浏览器如何解析 CSS 规则，并将其应用到 DOM 树上

#### 6. 浏览器如何将解析好的带有样式的 DOM 树进行绘制

#### 7. 浏览器的运行机制，如何配置资源异步同步加载

#### 8. 浏览器回流与重绘的底层原理，引发原因，如何有效避免

#### 9. 浏览器的垃圾回收机制，如何避免内存泄漏

#### 10. 浏览器采用的缓存方案，如何选择和控制合适的缓存方案

### Node

#### 1. 理解 Node 在应用程序中的作用，可以使用 Node 搭建前端运行环境、使用 Node 操作文件、操作数据库等等

#### 2. 掌握一种 Node 开发框架，如 Express，Express 和 Koa 的区别

#### 3. 熟练使用 Node 提供的 API 如 Path、Http、Child Process 等并理解其实现原理

#### 4. Node 的底层运行原理、和浏览器的异同

#### 5. Node 事件驱动、非阻塞机制的实现原理

## 六、框架和类库

轮子层出不穷，从原理上理解才是正道

### TypeScript

#### 1. 理解泛型、接口等面向对象的相关概念，TypeScript 对面向对象理念的实现

#### 2. 理解使用 TypeScript 的好处，掌握 TypeScript 基础语法

#### 3. TypeScript 的规则检测原理

#### 4. 可以在 React、Vue 等框架中使用 TypeScript 进行开发

### React

#### 1. React 和 vue 选型和优缺点、核心架构的区别

#### 2. React 中 setState 的执行机制，如何有效的管理状态

#### 3. React 的事件底层实现机制

#### 4. React 的虚拟 DOM 和 Diff 算法的内部实现

#### 5. React 的 Fiber 工作原理，解决了什么问题

#### 6. React Router 和 Vue Router 的底层实现原理、动态加载实现原理

#### 7. 可熟练应用 React API、生命周期等，可应用 HOC、render props、Hooks 等高阶用法解决问题

#### 8. 基于 React 的特性和原理，可以手动实现一个简单的 React

### Vue

#### 1. 熟练使用 Vue 的 API、生命周期、钩子函数

#### 2. MVVM 框架设计理念

#### 3. Vue 双向绑定实现原理、Diff 算法的内部实现

#### 4. Vue 的事件机制

#### 5. 从 template 转换成真实 DOM 的实现机制

### 多端开发

#### 1. 单页面应用（SPA）的原理和优缺点，掌握一种快速开发 SPA 的方案

#### 2. 理解 Viewport、em、rem 的原理和用法，分辨率、px、ppi、dpi、dp 的区别和实际应用

#### 3. 移动端页面适配解决方案、不同机型适配方案

#### 4. 掌握一种 JavaScript 移动客户端开发技术，如 React Native：可以搭建 React Native 开发环境，熟练进行开发，可理解 React Native 的运作原理，不同端适配

#### 5. 掌握一种 JavaScript PC 客户端开发技术，如 Electron：可搭建 Electron 开发环境，熟练进行开发，可理解 Electron 的运作原理

#### 6. 掌握一种小程序开发框架或原生小程序开发

#### 7. 理解多端框架的内部实现原理，至少了解一个多端框架的使用

### 数据流管理

#### 1. 掌握 React 和 Vue 传统的跨组件通信方案，对比采用数据流管理框架的异同

#### 2. 熟练使用 Redux 管理数据流，并理解其实现原理，中间件实现原理

#### 3. 熟练使用 Mobx 管理数据流，并理解其实现原理，相比 Redux 有什么优势

#### 4. 熟练使用 Vuex 管理数据流，并理解其实现原理

#### 5. 以上数据流方案的异同和优缺点，不情况下的技术选型

### 实用库

#### 1. 至少掌握一种 UI 组件框架，如 antd design，理解其设计理念、底层实现

#### 2. 掌握一种图表绘制框架，如 Echart，理解其设计理念、底层实现，可以自己实现图表

#### 3. 掌握一种 GIS 开发框架，如百度地图 API

#### 4. 掌握一种可视化开发框架，如 Three.js、D3

#### 5. 工具函数库，如 lodash、underscore、moment 等，理解使用的工具类或工具函数的具体实现原理

### 开发和调试

#### 1. 熟练使用各浏览器提供的调试工具

#### 2. 熟练使用一种代理工具实现请求代理、抓包，如 charls

#### 3. 可以使用 Android、IOS 模拟器进行调试，并掌握一种真机调试方案

#### 4. 了解 Vue、React 等框架调试工具的使用

## 七、前端工程

前端工程化：以工程化方法和工具提高开发生产效率、降低维护难度

### 项目构建

#### 1. 理解 npm、yarn 依赖包管理的原理，两者的区别

#### 2. 可以使用 npm 运行自定义脚本

#### 3. 理解 Babel、ESLint、webpack 等工具在项目中承担的作用

#### 4. ESLint 规则检测原理，常用的 ESLint 配置

#### 5. Babel 的核心原理，可以自己编写一个 Babel 插件

#### 6. 可以配置一种前端代码兼容方案，如 Polyfill

#### 7. Webpack 的编译原理、构建流程、热更新原理，chunk、bundle 和 module 的区别和应用

#### 8. 可熟练配置已有的 loaders 和 plugins 解决问题，可以自己编写 loaders 和 plugins

### nginx

#### 1. 正向代理与反向代理的特点和实例

#### 2. 可手动搭建一个简单的 nginx 服务器、

#### 3. 熟练应用常用的 nginx 内置变量，掌握常用的匹配规则写法

#### 4. 可以用 nginx 实现请求过滤、配置 gzip、负载均衡等，并能解释其内部原理

### 开发提速

#### 1. 熟练掌握一种接口管理、接口 mock 工具的使用，如 yapi

#### 2. 掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题

#### 3. 理解 TDD 与 BDD 模式，至少会使用一种前端单元测试框架

### 版本控制

#### 1. 理解 Git 的核心原理、工作流程、和 SVN 的区别

#### 2. 熟练使用常规的 Git 命令、git rebase、git stash 等进阶命令

#### 3. 可以快速解决线上分支回滚、线上分支错误合并等复杂问题

### 持续集成

#### 1. 理解 CI/CD 技术的意义，至少熟练掌握一种 CI/CD 工具的使用，如 Jenkins

#### 2. 可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括 Web 应用、移动客户端应用、PC 客户端应用、小程序、H5 等等）

## 八、项目和业务

### 后端技能

#### 1. 了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言

#### 2. 掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库

### 性能优化

#### 1. 了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案

#### 2. 了解常见的 Web、App 性能优化方案

#### 3. SEO 排名规则、SEO 优化方案、前后端分离的 SEO

#### 4. SSR 实现方案、优缺点、及其性能优化

#### 5. Webpack 的性能优化方案

#### 6. Canvas 性能优化方案

#### 7. React、Vue 等框架使用性能优化方案

### 前端安全

#### 1. XSS 攻击的原理、分类、具体案例，前端如何防御

#### 2. CSRF 攻击的原理、具体案例，前端如何防御

#### 3. HTTP 劫持、页面劫持的原理、防御措施

### 业务相关

#### 1. 能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题

#### 2. 能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题

#### 3. 可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性

## 九、学习提升

关于写博客说明下，能给别人讲明白的知识会比自己学习掌握的要深刻许多

#### 1. 拥有自己的技术博客，或者在一些博客平台上拥有自己的专栏

#### 2. 定期的将知识进行总结，不断完善自己的知识体系

#### 3. 尽量将自己的知识转换成真实的产出，不要仅仅停留在书面理解层面，更重要的是实际应用

#### 4. 坚持输出自己的代码，不要盲目的扎进公司业

## 十、技术之外

这部分可能比上面九条加起来重要！

#### 1. 了解互联网人员术语：CEO、CTO、COO、CFO、PM、QA、UI、FE、DEV、DBA、OPS 等

#### 2. 了解互联网行业术语：B2B、B2C、C2C、O2O 等

#### 3. 掌握互联网行业沟通、问答、学习的

#### 4. 有一定的"PPT"能力

#### 5. 有一定的理财意识，至少了解储蓄、货币基金、保险、指数基金、股票等基本的理财知识

#### 6. 掌握在繁重的工作和长期的电脑辐射的情况下保持健康的方法，建立正确的养生知识体系

## 十一、资源推荐

有了知识体系，在阅读一篇技术文章的时候就很容易把它归类，我一直以来就是这样做的。

事实证明，在阅读文章或书籍时，有目的和归类的阅读比"随便看看"后的只是留存率要高很多。

每阅读到一篇好的文章或者书籍，我都会收藏并归类到我的知识体系中。
学习一门知识，最好先阅读官方文档，把所有的 API 大概浏览一遍，再继续看大佬们总结的进阶知识，什么东西是搬运过来的，什么是干货，一目了然。
